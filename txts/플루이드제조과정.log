오후 2:10 2020-10-29
이관함,덮어쓰냐문제로부터.

우선 딕트부터 만들자.
플루이드 내놓기로했고,매우훌륭하고..

현재 되는게,고정사용하는
제목순정렬,날짜순정렬.ㅇㅋ.

필요한건

조회수
추천수
댓글수
.
제목은 특이하게, 내장하고있을텐데싶다. 흠..js가진짜안느린가;
그럼같은논리로.ㅇㅋ.


조회,추천,댓글 모두, 지금한다해도 뭐 볼수가 없다.나중에구축하자..
동의함.

태그입력기.기초적인 뮤즈태그부터 가능하게하는것.

본문뷰어. 본문을보면 조회수,추천수,댓글수 들어간다.근데 태그보기도해야함..흠..
간단힌 이거먼저하기좋네만, 분위기상은ㄹㅇㅇㅇ.

본문보기요청이,현재 지금 datas에 본문을띡가져오는것이고,ㅇㅋ.
no,본문
으로 가져온다.ㅇㅋ.
datas하나에서,미니datas를만들어서,그걸던져주자. vs
fluids에서 따로가져오기.

본문로드시
ㅇ본문
태그-없다!입력기필요

댓글들..저기서쓰면,여기서받는거네.ㅇㅋ.가능. fluid에저장됨.
추천버튼은 저쪽에서 요청해야함. 추천되면 fluid 에 저장됨.

이다.이게젤어렵다.

fluid의핵심을구성하는 태그부터 만들까싶다.
s붙이기귀찮으니 fluid로감.ㅇㅋ.유체니까.

fluid를구성하고, db와별개로 순수json으로 구동된다. txt만 접근하게됨.
db는 getjar, 등을하는거였으니.원래른그랬는데,모듈만로드해와서
결국 서버메모리에상주시키는게현재설계였지.ㅇㅋ.

db에서 넘치면 저기로 모듈로빼내면되고.ㅇㅋ.

fluid{}있고,

fluid[no]['조회수']+=1
매우잘됨.ㅇㅋ.
심지어 이걸 js명령으로 기록하는것도되겠네.오오.. 아냐 js. 파이썬이야.ㅇㅋ.;

조회수는어처구니없게도 이렇게 완료다.ㅇㅋ;
1.조회요청시,2.조회수+=1함.3.종종 조회수소트리스트 를업뎃함.ㅇㅋ.
2추천요청시,추천수+=1함.종종추천소트를업데시..

3댓글작성시,댓글수+=1함..?흠.하지뭐.ㅇㅋ.근데1줄차이다.하지말자.ㅇㅋ.관리대상2개니.
3-댓글작성시,플루[넘][댓].append( 댓글내용) 한다.진짜오지네ㅋㅋㅋㅋㅋㅋ

4.태그입력시,플루[넘][탯].append(태그내용)한다.진짜오지네ㅋㅋㅋㅋㅋ
논리가같다.최고다.
태그입력기도 동이랗게가고 태그는근데계정명이필요함.동의하공.어케하지?
유저태그[1,2,34,,] 는 이름 붙이지 말자.ㄹㅇ그냥이대로두고
로그에만 기록해서,요놈녀석하고 지워버리게하자.ㅇㅋ매우동의함.
큐레이터도아니고말야.큐레이터면의미있지만.. 그건 로그에서따로내자.너무더러워져.
논리가얼마나좋니 ㅣ니ㅣ니ㅣ..아니다니!!

댓글도동이ㄹ하게 입력자 구분해야함!
댓글 = [   [작성자1,작성시간,댓글내용] ,  ... ]  ㅇㅋ. 이이상일필요없지?
ㄴ근데구조상으론 json이낫네.
댓글 = {  작성자1:[시간,내용] , ..} 동의함.ㅇㅋ.ㄱㄱ.
태그 = [  작성자1:[태그내용]도,
태그 = { 작성자1:[태그1,태그2,...] ...}
ㅇㅋ큰차이없.

근데,사람이했단게..그렇지뭐.로그를보면

fluid[no][tag]['니코'].append(과식)
이 되겠지.진짜좋네.. json으로유지되는게멋짐.
logue신설.ㅇㅋ.

로그는 []가낫나싶어.순서가 json은 없으니까.바로접근하는키지..
로그이력키를 두자면어떨까싶긴해.인덱스+=1을해야하지만..
keys로내놓나?
len으로내놓지!흠..이러면 그거위배되긴하는데 일단됨. 1234 6이면 6 덮기전엔계속됨..
그리고 더 늘질 않아. ..? ㅇㅇ 그게없으면. 키가위에훌쩍있으면.
근데논리상절대안무너지겠지싶은데요..

max(list(a.keys()))
로얻을순있지만..별로같긴하지.개념상은이게맞지만.

앷에근데접근을안하니까..흠.
ㄴㄴㄴ이건 ilst가..아.그거랬지.ㅇㅋ.. json바로저장과 바로이송이 얻는 혜택이라니.
미쳤지만 그런으미ㅣ에서괜찮으니 이렇게 ㄱㄱ.
[
    1,
    2,
    3,
    "ha",
    "11"
]
리스트합시다.ㅇㅋ..
뭐 아주잘되네요.ㅇㅋ.
시간순으로적재되고 인덱스가 0부터나가고 관리쉬우니 ㅇㅋ.
로그는 list로,json형태로쓰도록함.ㅇㅋ.
어처구니없이잘됨.ㅇㅋ..
명령어를말이죠,그대로저장합니다,,그러고반대로할까요?
리스트에 명령이저장되는데요.. addn같은경우는 추천수면, 추천인도 들어가야해.유저도.
유저,넘버,값 으로가지뭐.모든경우에될듯.ㅇㅋ.

로그
유저1이,넘버1453의,키[추천수]에,add했다.
명령자체는 상위명령자체가그렇군.ㅇㅋ.
텍스트로우선복원가능하면그걸로충분한거야,
리스트는 라인으로 txt로얻고빼기가되니.ㅇㅋ.굿.
그래서리스트가좋구나..!

>>> user='마키사랑해'
>>> no=1251534
>>> key='추천수'
>>> "addn({},{},{})".format(user,no,key)
'addn(마키사랑해,1251534,추천수)'
가 된다.이거면되지?

fluid['1251534']['추천수']=44
이렇게 다이렉트어사인은안됨.흠..
fluid['1251534']이게 dict가 아니기때문이지.ㅇㅋ.
fluid['1251534']={}
fluid['1251534']['추천수']=44
안된다!
addn('마키사랑해','1251534','추천수')
>>> addn('하나요','11','추수')
>>> fluid
{'11': {'추수': 5}}
제대로동작함.
jsonlistdump에 실험한게있다.ㅇㅋ.
4
["addn('하나요','11','추수')", "addn('하나요','11','추수')", "addn('하나요','11','추수')"]
["addn('하나요','11','추수')", "addn('하나요','11','추수')", "addn('하나요','11','추수')"]
후후후후.후후후후후ㅜㅎ..입력/출력결과가같다.
[
    "addn('하나요','11','추수')",
    "addn('하나요','11','추수')",
    "addn('하나요','11','추수')"
]
ㅇㅋ.이거면 역연산가능함.
..이랄까..흠..
add의역이 sub이니까 변환하면됨.ㅇㅋ. 이건 하지.
for i in ll:
	print( i.replace('add','sub') )
이렇게간단히될줄야;역시파이썬이좋아흑흑흑
exec()
이거였나..가물가물.ㅇㅇ 스크랩에서씀.
오전 6:01 2020-10-29
ㅋㅋㅋㅋㅋㅋ진짜잘됨. 황홀함에가깝다. 난 , 내존재이상의걸 느끼는거야..
뭐야6시네 자자;

완-벽히 논리적으로적절히동작함.진자 정수다 이건...
그..로그는..
["addn('하나요','11','추수')",
 "addn('하나요','11','추수')",
 "addn('하나요','11','추수')",
식으로있는데요..이러면 누가했나를 검출하려면..
for i in logue:
	if i.split("'")[1]:
	    print(22)
으로어떻게든잘됨.ㅇㅋ..

오전 6:12 2020-10-29
아무튼잘됨

N은그렇게되고,
addn은그렇다쳐도
add면 역연산하고
거뭐냐그거면 그렇게하게하지뭐.ㅇㅋ.일단 유저입력까지도함개꿀이야진짜;

오전 6:18 2020-10-29
자자.곧.

fluid의 키는 죄다 "333"으로처리하도록.명심하자..

fluid['1251534']['추천수']=44
인 식이고, 안은 int여도 어짜피복구하면그렇지않나싶어..흠.
>> cc
{'11': {'추수': 3}}
int네.
{
    "11": {
        "추수": 3
    }
}
ㅇㅋ.그럼 형변환없다고확신하고..
str엔 연산못하는게 파이썬이니 ㅇㅋ.확증하고감.
js에 너무 더럽혀졌어..흑흑.

아그래서 뭐였지..
댓글은,역역산논리가..

dict에, 잘있고요..
댓글 = {
작성자1:[시간,내용] ,
작성자1:[시간,내용] ,
}
뭐야이럼전역댓글리스트잖아.
fluid의 no번의글에 key에서 ..가 아니네.흠..
ㄴㄴ맞는듯.
fluid[no][key][user]= time,text
에서, ()할까 []할까.흠..

도동이ㄹ하게 입력자 구분해야함!
댓글 = [   [작성자1,작성시간,댓글내용] ,  ... ]  ㅇㅋ. 이이상일필요없지?
ㄴ근데구조상으론 json이낫네.
댓글 = {  작성자1:[시간,내용] , ..} 동의함.ㅇㅋ.ㄱㄱ.
태그 = [  작성자1:[태그내용]도,
태그 = { 작성자1:[태그1,태그2,...] ...}

뭐야..태그는[]겠지.ㅇㅋ..

fluid[no][tag]['니코'].append(과식)
이 되겠지.진짜좋네.. json으로유지되는게멋짐.

흠..
계정을둘까요?안둬도 역연산은가능하리라확신함.ㅇㅇ.
일단안둬보자.ㅇㅋ.댓글관 상태가다르니.ㅇㅇㅇㅇ.

fluid[no][key][user]= time,text
이러면 순서가..타임으로되네.오지군;초까지넣고 표기만그거로하지싶다..?너무한데;
key=닷글
fluid[no][key].append( 유저={ 시간:time , 내용:text} )

이건어떄?되게더러워졌으나,논리적이나,더럽다만,[]라서 일단 인덱싱이됨.ㅇㅇ.
댓글순을 len할때같이구해??것도편하긴하네,매번전역스캔은안할거야. 흠.


일단 고민은있으나,
조회,댓,추
태그
의 첨가논리를 구축흐였다.ㅇㅋ.

소트시뭐더있던가일단은ㄴ.

좋아요버튼이 개추와구분될핑료가있을수도.ㅇㅋ필요시추가함녀됨ㅇ.ㅋㄱ꿀
오전 6:42 2020-10-29

태그엔 ㄹㅇ 이렇게하면됨.지우기도쉽고.ㅇㅋ동의.
각명령은 t/f반환하게해서 나름규격갖추고

댓글은,댓글도인덱스들어가니 그리하자.
[댓글].append( {작성자:user, '시간': 오전 6:43 2020-10-29, '내용':'235236236236'} )
[]로해도,지리적이점이라고보기어려우므로.훌륭한구분.ㅇㅋ.
댓도 시간순이의미있다.ㅇㅋ.

a.index('df')
리스트 역추적발견함.오오. ..?이거되게공격적..
a.remove('df')
ㅇㅋ

>>> a.reverse()
[2, 1]
>>> a.sort()
[1, 2]
ㅇㅋㅇ
오전 7:15 2020-10-29
자자..해가..

오후 2:10 2020-10-29
실험데이터갖고.

>>> keys = ['a', 'b', 'c', 'd']
>>> x = dict.fromkeys(keys)
>>> x
{'a': None, 'b': None, 'c': None, 'd': None}
dict.fromkeys(키리스트, 값)처럼 키 리스트와 값을 지정하면 해당 값이 키의 값으로 저장됩니다.

>>> y = dict.fromkeys(keys, 100)
>>> y
{'a': 100, 'b': 100, 'c': 100, 'd': 100}

디폴트선언이 가능하고, None으로 입력되는게 핵심이다. 후..
심지어 지정해서입력도 되네..
새로운 객체를 우선 이렇게선언이되겠어.흠..
지금 알다시피,없으면 --한다 였는데 None채우기가되네.
txt에서체커는 형식검증이었지만.

플루이드쪽이니 여긴 별개의일이다.ㅇㅋ.
키값에 미리 선언이필요하고..없으면 오류나니까.

defaultdict는 없는 키에 접근하더라도 에러가 발생하지 않으며 기본값을 반환합니다. 
defaultdict는 collections 모듈에 들어있으며 기본값 생성 함수를 넣습니다.
from collections import defaultdict  
응 안 해

https://stackoverflow.com/questions/8214932/how-to-check-if-a-value-exists-in-a-dictionary-python
'one' in d.values()
True
..뭐야느린가

디폴트를잡기에 동의함.ㅇㅋ.매우빠름.
디폴트를 이러면 다 []로 잡을까싶어, []면 없단소리니 같은규칙적용됨..

fluid[no]={}
fluid[no]['조']=0
fluid[no]['좋']=0
fluid[no]['추']=0
fluid[no]['댓']=0
fluid[no]['태']=0
fluid[no]['태그']=[]
fluid[no]['댓글']=[]
뭐 이런느낌이겠지. 지금하는게 datas가아니니 저쪽은 무시하고..

플루이드의[no]가 디폴트로 선언되는게 가능할까..?
no가 처음 언급될 때, 선언하는건 가능한데말야.
a in dict.values()
는 너무느려.30ms 이따위임.
..아닌거 같은데요..

10만이라그래!
10만에 4ms걸리고, 2만에 1ms.ㅇㅋ.

if '444' in ddd.values():
스트링으로테스트됨.

fluid..
datas불러와서,그걸그대로집어넣지싶음. ..은큰일..나나..?
1.플루이드에 없고 datas에 있으면,
2.플루이드추가모드 수행. no를 받아서, 디폴트선언한다.ㅇㅇ가능함.
fluid[no]={}
fluid[no]['조']=-1
fluid[no]['좋']=-1
fluid[no]['추']=-1
fluid[no]['댓']=-1
fluid[no]['태']=-1
fluid[no]['태그']=[]
fluid[no]['댓글']=[]
이렇게만해주면됨.ㅇㅋ.
..간단하네.
이게아니고선,어쨌든 addn을 수행해야하는데 암것도없으면안되지,그걸매번확인하는게정말싫은거야.
이경우,datas지워져도 보존되고있고,일치가아니니.
datas더들어오면,그만큼추가될것.ㅇㅋ.

신입 리스트를 그냥 만들까?그게낫나??

-1하면 선언전인데 +가 가능하니 별로같아.
[]로하면, []면어짜피못하지만 그러니확인하면되고.
근데 심지어 0이면 그냥 하면됨;흠.. ㅇㅋ그러네! addn은 무조건사용가능해짐.ㅇㅋ.

오후 3:09 2020-10-29
후.fluiddb 개설함.매우훌륭.매우...

[]더하기성공.
로그에어펜드 실패.
이경우엔, false가 반환되는데, []는성공했으니 알게모르게기록되어있다.어쩌지?
except면,된걸 되돌리고가야해.ㅇㅋ.


def addn(user,no,key):
    k=0
    try:
        fluid[no][key]+=1
        k=1
        logue.append( "addn('{}','{}','{}')".format(user,no,key) )
        return True
    except:
        if k==1:
            fluid[no][key]-=1
        return False

이렇게했다..쓸데없이엄청길어져버렸군;

def addn(user,no,key):
    k=0
    try:
        XXXXXXXXXXXXXXXXXXXX
        k=1
        YYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
        return True
    except:
        if k==1:
            reverseXXXXXXXXXXXXXXXXXXXX
        return False
인데말야.

그리고,except수행중 에러나는경우는 곤란하다.
ㅇㅋ.
흠.간결하게함.2줄더줄임.

def addn(user,no,key):
    try:
        fluid[no][key]+=1
        k=1
        logue.append( "addn('{}','{}','{}')".format(user,no,key) )
        return True
    except:
        if k: fluid[no][key]-=1
        return False
명확하고,한줄이다.괜찮아뵘.. 여기선 직접 값 연산이라 이게오류날까싶기도하고.이전에되었는데
여기서안된다고??가힘들지싶다..

subcomm(user,no,text,time):
에선,댓글내용을 보존하고있어야하나??시간하고??
흠..
ㅇㅇ당연.ㅇㅋ. 지울거면, 읽어서,집어넣으세요.
근데이런경우가있을까싶다..금융도아니고 원;
아니,값은했는데,로그에 기록못하는경우가.... 충분히있다.ㅇㅋ.
logue.append( "addtag('{}','{}','{}')".format(user,no,text) )
에서, 아무튼새로추가하는거라서 명령자체가문젠안되나,
1.[]가 쓰기잠금걸림
2.유저명이 이상한거라서 규약위반 ..?
유저명을 str로받게만하면 절대문젠없겠지싶다만요..

일단은믿고가자,솔직히진짜아닐듯;
2중루프는고려가능한데..ㅇㅋ넣기.
..보기더러워진다.흠..

1.태그지우고,오류를내게되면,, 태그는없어졌는데 로그는..하..
ㅇㅇ정신나간일이야.이럴거면 
i+=1
if i_before == i: i-=1
이따위로해야하잖아.어휴;

ㅇㅋ.
일단 좀 위험하게간다. 태그뺐는데 로그에 안 남거나, 태그=[1,2,3] 태그수=2인경우가 발생할것.ㅇㅋ.

오후 3:41 2020-10-29
잘하고있었고

def getJson():
    global datas
    jsonName = 'datas.json'
    datas = minidb.loadJson( jsonName )
    return 'getjson'+str(len(datas))
에서, global 선언이 필요할까???
서버에서 돌아가는 datas란게 유일하잖아.
아마도, 일단 main일때 ..아..main이 아닌가...

웨이트리스에서 부르니까 그럴 수 있겠어.흠..
app = Flask(__name__)
@app.route('/')
def hellow():
   return 'hello'
흠..
@app.route('/get')
def getJson(datas):

이럴순없으니까 그런거아닐까싶은데..
좀 이해는 되겠어.ㅇㅋ.

@에 딸린건 글로벌변수를 끌고와야한다고생각해.

@app.route('/bodyload')
def bodyload():
    global fluid
    tmp = fluid[n][key]

식으로말이지..

def addn(user,no,key):
    try:
        fluid[no][key]+=1
        logue.append( "addn('{}','{}','{}')".format(user,no,key) )
        return True
    except:
        return False

@app / viewiing...
def view
   ...senddata
   addn(user,no,'뷰')
흠...

@app / viewiing...
def view
   global fluid
   global logue
   ...senddata
   addn(user,no,'뷰',fluid,logue)
이건정말싫을듯;근데이렇게동작하지않으려나;

   addn(user,no,'뷰')

def addn(user,no,'뷰',fluid=fluid,logue=logue)
로 하자..?
ㅇㅇ.동의함.
일단실행해오보.요는 웨이트리스에서갑자기발생시로군.

오후 3:52 2020-10-29
아...app이 클래스라고 가정하자.
app.run() 이니까.

class app .........
@app.route('/bodyload')
def bodyload():

class app .........
    self.bodyload()

뭐이런느낌아닐까.
ㅇㅇ.클래스의 내부 메소드로 할당이되는거야.
그래서,클래스외부에서 끌고오고자 이걸 쓰는거지.
그렇다고 app 안에 datas를 우겨넣을순 없잖아;

datas={}
class ma():
   self.name = datas['이름']
응 동작 안 하겠지.
ㅇㅋ.
..이렇게보니 되면 그게 이상한거같은데요...

하.
global datas
    nostr = backupDatas()
def backupDatas(datas=datas):
안되었다..

집어넣어야만되는듯.;
...???
datas가 {}로 잡혔나;

ㅇㅇ함수선언때 애초에 그러니까말야.
...아닌가;

메소드.

fluid.addn(user,name,no)
는 어떨까.괜찮은데..매우우아하고.동의함.오...오...
단일함수가아니라 메소드자체에접근하고
변수등은그안에저장된다.
신개념이다.매우우아함.
!
그래,애초에 raw하게 플라스크에서 이걸 끌어쓰는게 이상했던거야!

하긴,db를 안거치고서 애초에 접촉할 일이 없던거야!!

valueText = datas[no][key]
지금은 이걸 막 끌고오는데
valueText = minidb.datas[no][key]
이렇게만되면됨.직접접속할거면.
fluiddb.fluid[no][key]
ㅇㅇ동일하다.
하..진짜멋있군.


아 녹화할걸. 어제 12시부터 8시간,오늘 3시간이 어마어마했다정말.

심지어 db를 py로 두고
이전엔 함수실행목록이었던게, 지금은 그냥 변수까지 넣어버려서 처리할수있게됨.
별거아닌데 충격적인 개념의 확장이다.

마치 클래스 fluiddb 를 둔 마냥 ,내부 메소드,변수를 이용하게되었다.ㅇㅋ.

오후 5:36 2020-10-29
크롤링했고,밥먹었고. 2018년6월까지했으며 오류 2개나왔다.

오후 5:52 2020-10-29
실패뜨면, 이전의 fluid를 교체하는건..하지말고;
실패는 깔끔하게 반환하는걸로하고
근데 그건할만하네 ㄹㅇ;인데 매번 fluid를 백업하는게 심히 빡칠거같은데요..
len(fluid)이랑은 노상관이고.ㅇㅋ.그럼냅두지뭐 ..가아니고
len(fluid[no])도 동일함.ㅇㅋ.냅두자;

oldno = fluid[no]
if oldno != fluid[no]:
 open ( errlog,encodeing)
write
close

는 할 만할듯.동의는함..
인데, 매번 체크구문 써야하는거 정신나갈거야.하지 말자!

아냐,저기에하는거라할만할거야.?
근데 except...여도 ㅇㅇ그러네 , fluiddb측에서 에러남기면되니.ㄱㄱ.

o==fluid['33']
말도안되는일인데, o가 복사가 아니라 참조로들어간듯함.세상에나..!

n=0
a= n
n+=1
a
이건괜찮은데말야.

a= dict( fluid['33'] )
심지어 이것도..
아하.형변환해서하지.ㅇㅋ.

oldno = str( fluid['33'] )
ㅎㅎ잘됨.ㅇㅋ.

중복태그가허용된다. 카운트도올라갔고. 리스트는중복못거르니.ㅇㅋ.
'밥줘' in fluid['33']['유저태그']
로 ㄱㄱ.ㅇㅋ.

if no in fluid.keys():
            1+'1'
이따위 판별문괜찮겠지? raiseerr를 한것.
no가, 플루이드키에 없어야만해.
있으면 오류나게해야하는데..
오후 7:27 2020-10-29
작업재개.

logue를 두개 운용해야겠다가 된다.

datas엔,그러나,딱히..
아 ㅋㅋㅋ 애초애ㅔ fluid니까 로그가 있는거군.ㅇㅋ.
datas는 별개로운용되고.ㅇㅋ.

플루이드에이미있는경우, set을못하게해야겠지?
응.지우고 초기화 하세요.
del fluid['33']
ㅇㅋ.

플루이드보고 백업하라해야해.ㅇㅋ..

오후 8:24 2020-10-29
key='댓글
인풋체크때 키도 체크 하게 할까??
그냥 이건 안 하는게;;키는 애초에 유동값이아니야!

addn(user,no,key):
에선 key를 받고, 얘는 ,, 여기코드안에서 지정된 '태' 같은거만받는다.ㅇㅋ.
ㅇㅇ일단 실패하면 false 내뱉는다.어휴좋네;
그럼 인풋체크도 어짜피안해도 오류나오는거아닌가요..흠..

아.이거계기가, no가 int로 들어올경우를 대비한거였어.
근데 이거랑,진짜오류랑은 구분할 가치가 있겠지.ㅇㅋ.

addn('ha',22,'추')
input type error
False
ㅇㅋ.매우잘한듯. no는 외부입력받는거니까. 잘한듯. 다 스트링으로받게하고
권장을위한 메세지인것이야.ㅇㅋ.
이게없으면 no가 int인걸 눈치못챌테니..ㅇㅋ.
글고좀너무수상하니 프린트라도하게할까싶은데
프린트는 결국 서버측에되니 흠..
정확히는, t/f와 함께 오류메세지가 나오는 print를 캡쳐해서,
클라한테 던져주거나해야겠다만..흠..

except Exception as e:
        print(e)
로 수정하게하자,이것만해도훨낫네.그리고 이거 정직하게 에러 잘 출력해.허참..
Exception(' no already was. in fluid')
이니까.하하하.. 저건 그럼 코드에서 줄추적하려고했던거군;어휴.

no => nosrt 다 바꾸려다 안해도됨ㅎㅎ 너무다행이다...
가독성이 파이써닉하지.ㅇㅋ.

>>> addn('하나요','334','추')
'334'
False
뭐,나쁘지않지.ㅇㅋ.

addn(11,'33','추')
input type error
input type error
False
흠..
addn('우미','33','래')
'래'
False

sub을 그거로바꿀까싶지만,규칙에의해고정됨.ㅇㅋ.

0보다작으면..? 냅두지뭐.추천수도있고.ㅇㅋ.
굳이하려면 다 고정하는데,에휴 인것이야. ..?

addtagm('{}','{}','{}
리버스함수?

'2020-10-29 21:25:57'
끼리 그냥 비교하면됨.ㅇㅋ.
애초에 비교랄거도없지,겠지만!
댓글에만유일하게쓰일거같았는데, 로그에도 남기자.ㅇㅋ.맨뒤에붙이기
로그엔, 파스&리버스 를 하게 하지.
파스 코드가 어디갔지..
[
    "addn('하나요','33','추')",
    "addn('하나요','33','추')",
    "addn('우미','33','조')",
이게 현재 기록이야.
아..스플릿문자를 뭐로하든 그 문제가 생기겠네;;;

"addn('우미','33','조만간(진실)이 밝혀질것이다..후후후..')",
맨뒤에서 19자리끊기로!ㅇㅋ...가아니고 흑흑흑
19자리가안돼!!
그냥 그걸인코딩할까? 정보량이란의미에선.흠..
ㄴㄴ보기좋아야해 ㅇㅋ
이제문제가,알다시피 이걸 자리수로끊을수없어.
문자로도끊을수없어.
곤란하구만..
[정보,일시]로 남기자.ㅇㅋ.

하하..이러면 정확한걸못지우네;;

addcomm은, 리스트에,추가하는데,
[
{작성자:
내용:
일시:
},
]
이다. 자동정렬되면안되고,정확한 값을 지워야 해!
subcomm(user,no,text)
애초에 명령이 이렇잖니.흠..
같으면그냥지워버릴까싶어.ㅇㅇ.
우미가 1이라 씀
우미가 2라 씀
우미가 2라 씀
우미가 2라 쓴걸지움
우미가 2라 쓴걸지움

순서상관없이지워버리는거지만뭐.본문정확히같겠냐고의 주장이야.

여기서이제 기가 막히게도, 저장된데이터는그대로 들어가려나??
흠....
time.gmtime()
등 발견하는중.ㅋㅇ.에포크 이후로잡히는군.넘좋다. 2038년되면 막힌다네 엌;32비트.ㅇㅋ.
이게하나의 id가 되고 일치가능하다. html에서 파스해서보여주기만하고
데이터로서는 원값을최대한보유하는게낫지. id로 삭제생성되고, 로그에남길땐
(1,2)로 남겨서, [0]만읽게하자.진자멋있다.

https://docs.python.org/ko/3/library/time.html#time.gmtime
>>> time.time()
1603975587.2778106
>>> time.localtime()
time.struct_time(tm_year=2020,
>>> time.asctime()
'Thu Oct 29 21:48:53 2020'
>>> time.gmtime()
time.struct_time(tm_year=2020, tm_mon=10, tm_mday=29, tm_hour=12, tm_min=49, tm_sec=16, tm_wday=3, tm_yday=303, tm_isdst=0)

gm으로가자기준을.ㅇㅋ. ..ㄴㄴ 이러면 한국시랑달라서 추적불가함.ㅇㅋ.

+9기준이젤낫긴하네.

>>> time.time()
1603975587.2778106
이게 원 시간이고 초의소수부는무시.ㅇㅋ

https://wikidocs.net/15106
이게훨좋네.

time.gmtime(1575142526.500323)
어후..이러면 스트럭트타임으로 다깨지는데 그냥 이거쓰자 ㅇㅋ.

time.time()
이걸id마냥쓰고
rawsec = int(time.time())
tk = time.gmtime( rawsec )
GMT 기준ㅇㅋ 그거만 한국형으로하자..니까
tk = time.localtime( rawsec )
timestr=''
tx=['년','월','일','시','분','초']
for i in range(6):
    timestr+= str(tk[i])+tx[i]
yeah

id를 아예 시간이걸로가져가면??괜찮은데???
초 문제. 아..설마...제발아니겠지..
1초의 정밀도면 근데 좀 이상하긴 하긴하지;
ㅇㅇ 도배기 막 돌려서, 1초당 100번 입력되어버리면 어쩌라고.
이미있으면,안합니다 정책에 의해 방지됨.ㅇㅋ개꿀.ㅋㅋㅋ

흠. dict에 접근시 보기 불편하긴하네..만
1.로그에쓰인다
2.그외엔 독립id로 기능하게한다
3.그러면 그냥 일시를 거대str로 보기좋게하면어때??
4.안될거뭐있노
아하.이게,그게이미있으면안되는게검출이안되어서그래.

fluid[no][key].append( {'작성자':user, '내용':text, '일시': time } )
인데, append라서 무조건들어가고본다.

fluid[no][key].append(text)
태그는. 이게,..추가니까되고,,삭제를하면.. 해당태그가소멸함.ㅇㅋ.
이미있으면안되는건 cansubtag로 했군.ㅇㅋ.

fluid[no][key].remove( {'작성자':user, '내용':text, '일시': time } )
이게정확해야한다는데요,안되지않을까요?
아.그건ㅇㅋ고 str변환된후니 ㅇㅋ.
append를 막기위해 cansubtag 를 했잖아.
이걸또해야한다고 봐.

fluid[no][key][1] = {'작성자':user, '내용':text, '일시': time } )

for i in fluid[no][key]:
if instr == str(i)
너무별로;

not in list 로잘됨.ㅇㅋ.

id를 키값으로하쟀지.ㅇㅋ.해결.

그럼 timeid 인 int를 어따쓰지??
1.보여주기 2.소트하기 3.로그하기 4.파이썬입출력하기
굳이 id가 아녀도 된다! ㅇㅋ.

'2020년10월29일22시28분10초'
나쁘지않아. 6*2만큼의 바이트가 추가될뿐.ㅇㅋ이걸로감.
길다고문제되진않겠지뭐.
2020-10-29-22:28:10
이건 가독성문제가 심각해.

아 그리고 fluiddb는 구조적으로 datas와 구분되어있다;; 아그러네
이건 로그와,댓글로드시 보이는날짜 에만 쓰인다.ㅇㅋ.
...년월일들어가면 너무정신없긴하네;
2020-10-29-22:28:10
이거로할까..?

10.29 22:21:26
2020.10.29 22:19:24
흠..
이걸로하자.ㅇㅋ.댓글은 2020안보이는게낫기보단 스타일로숨기나;
만약 ==현재년이면,생략한다.
ㅇㅋ.
2020.10.29 22:19:24
파싱은어렵지만 훨낫지싶어.제조당시에 기록해두지뭐.
2020.10.29 22:34:48
ㅇㅋ;20초만에해결됨.
https://www.w3resource.com/python-exercises/python-basic-exercise-3.php

댓글정보
 {'작성자':user, '내용':text, '일시': time }
에서,
이게 리스트로 들어가..서그렇군! 순서를 가진것으로.
근데 dict여도 일시가 인덱스로 기능하게되는것같아,지금은.
흠..그럼 태그도 {}로 해서 인덱스로 datestr넣을까?
작성자내용은중복가능하니까.ㅇㅇ.
리스트라서좋았다: 반복되게추가되는것이 자동 들어온순서가됨
역정렬편함

아냐..태그는 완벽히 중복이가능하..지않은구조네..하 그런가..
ㅇㅇㅇ중복거를거면 애초에 그렇게했어야해 싶어.
fluid[no][태그]={ '호노카':'' }
ㅇㅇ 이건 리스트가낫지싶다. 키 안의 값을보려는게아니니까.ㅇㅇ.
그럼 냅두고 댓글만 다시보자..

댓글을, 댓글={
일시={작성자:사람이름,'내용':어쩌고저쩌고},
일시={작성자:사람이름,'내용':어쩌고저쩌고},
}
이래두면 정렬이잘되어있지.

우미:도배기돌림ㅅㄱ
우미:도배기돌림ㅅㄱ
우미:도배기돌림ㅅㄱ

하고 있는경우,이걸어케지우지?
[1]식으로접근하긴 너무위험해.

1.(user,no,text) 의 튜플.고정되겠지.
2. str({})인데 이건 좀 이상함.ㅇㅋ.
fluid[no][댓글][i]
ㅇㅋㄹㅇ그러네. [댓글][작성자] 가 아니었어.ㅇㅋ.휴.해결.
애초에, A;B였는데 키로 접근할게아니니까 dict가불필요했던거야.ㅇㅋ..
a[2]='소망'
튜플은 아이템어사인먼트 허용안함.ㅇㅋ.
ㅇㅋ수정대신삭제를이니.

타임은 매 수행때마다 수행되어야 함이 마땅.ㅇㅋ.
깔끔히 처리됨.

logue.append( ("addcomm('{}','{}','{}','{}')".format(user,no,text),time) )
로그는 이렇게 타임을빼놓고..아 {}3개로하고
타임은 매번수행.그게마땅하고.추가하기보단 로그에만추가함.ㅇㅋ.
로그는 그냥 []라서 잘들어가는게 다행이야..

오후 11:37 2020-10-29
...다된건가??

태그랑 유저태그구분,여기서만 독립적이네.어떻게할래?
태그는 태그로두고,
뮤즈태그를뮤즈태그로두자.그게현명함.
저기가면 다바꿔야하지않던가요;;
js측에서 구축된 거대한형태가..ㅇㅇ그런듯..?

바꾸는게무린아닌데 함수명때문에 드럽게얽힐거야.
fluiddb측에선 수정이 쉬우니까.현행유지로.ㅇㅋ.
..굳이말하자면야, 내보낼때 변환을하면되지만 그런건 정말별로지.ㅇㅋ.

datas는,로드후..하면내보내는거같았는데,,갱신하는거였지.
jsonio라이브러리에 이걸 빼둘까싶어.

1.기존것로드함.
2.현재있는거랑비교.추가되었으면저장.
..수정시는어쩌라고.
dict를 str로 바꾼뒤에 해시쓸순있네.흠.
바이트코드마냥 다르면 반영하기라.동의는 함..
아.읽을때 그냥 바이너리로읽으면 그게그거겠군!..은아냐. dict를바이너리로만드니.

for i in range(10):
  fluidset( str(i))
이렇게하기좀귀찮긴하네.이거만봐줄까?
이건실제로도쓸함수라그래.ㅇㅋ.

for k in fluid:
	fluid[k]['조']+=1
흠.이래도될텐데말야.근데 insure하기위해서니까뭐..ㅇㅋ.4배는느려질듯;
근데 ㄹㅇ잘한듯.ㅎㅎ.인터페이스구축이야.
극적으로 파이썬몰라도 구조적으로동작하는게되는군이거!

오전 12:02 2020-10-30

subcomm('니코','33','밥먹고싶다')
list.remove(x): x not in list
False
이거빼곤잘됨.ㅇㅋ.


backupfluid()
backup no: 2
>>> backuplogue()
backup no: 0
로그가왜0이지;
아.그냥그거임.ㅇㅋ.
되게길게잘됨.


오전 12:10 2020-10-30
[
    [
        "addn('하나요','33','좋')",
        "2020.10.30 00:05:20"
    ],
    [
        "addn('하나요','33','추')",
        "2020.10.30 00:05:27"
    ],
    [
        "subn('하나요','33','추')",
        "2020.10.30 00:05:31"
가독성조졌다..하...
일단기록은잘됨.
로그는 별개로운용하지싶은데
native json load가 원했던거긴하지.흠..
parse해서불러올까싶다만.
이것도그냥밀봉할까싶기도??
날짜자첸 이벤트라 반드시 포함되어야함.
이중[]고, ()가아니네.ㅇㅋ.

댓글편향.글편향.


1.로그파일이매우더럽다
2.댓제거가안됨.
3. 거대 진영 구분 문제. 일부만보이게하나?


데이터베이스에, 보이기/안보이기 옵션을 하는건 말도 안 된다. 논리는 같아야지.

1.사이트링크자체를 분리해서 굳이안원하면안보러가게하기
2.아예 로그인사용자만 특수한 선호도를 보이게 하기..
요청사항은
1.댓글은 감춰져야한다. 태그도.
2.이미지는 a,b 버전이 있고, 선택가능해야한다,애초에 보는 일이 없도록 철저히..

중복파일용량문제가있는데, 혹시다른거만..이면 하게하고 ,이미다르면 당연히 ㅇㅋ지.
그리고애초에 1기가짜리라 그냥 하는대로하지싶기도한데,그것은낭비다.
static
origin
resized
thumb
+++uslam
의도적인파일만하면됨.
ㅇㅇ이게낫지.
파일은 datas관여함.격리됨.ㅇㅋ.굿.

댓글은?
태그는?
둘다 fluids에서 관리하지.보자..

댓글엔 현재 쓰기등기능들어가고 잘 관리됨.ㅇㅋ.

전역 뮤슬람 기능 ON 이 필요하고,
1.물자이크버전의 이미지를 제공함
2.태그에서 일부태그들이 안 보임.
3.이상한 태그들이 보이기 시작 함
4.안보일법한 댓글이 보임
이다.

숨김처리는 좀 이상해.개념적으로 구분되어야좋겠어.근데 굳이찾아들어가야볼수있도록하고.
view2를 둘까 싶음..
/view
/uslam
인거지!

전역 최신 댓글 보기가 필요해. 소트에 넣자싶음..
전역 댓글게시판도 필요해.댓글관리용.
전역 특수메세지 보기도 필요하고.

1.로그파일이매우더럽다..1줄로보이게해야. []는안된다.
2.댓제거가안됨.
3. 거대 진영 구분 문제. 일부만보이게하나?

댓글에아무리그래도 ..는좀이상해.ㅇㅋ.
일단 유저를 넣었는데,유저목록을두자싶음.
개념적으로.ㅇㅇ.

태그는 평등하지,현재.
이걸,태그에, 일부는 감춤처리 하게 해야 한다.

아니면 보이지만않게하고,
글자체엔 모조리넣어있게하면되겠네.투고만하는거니까.ㅇㅇ매우동의함.

글삭제가기본적으로 안되게했으니까.

태그리스트.우르르존재.구분은불가.
유저1이 한 일이, 뮤슬람이다. 이사람의 모든 행적을 보통은 안 보이게 하자.
도 괜찮겠고.

글에는 태그가할당되고
특수,뮤즈태그가 또 존재하게하지뭐.ㅇㅋ그럼되네 .기능적으로 구분되어있다.ㅇㅋ.

fluids={}
fluids[id]={}
fluids[id][key]
keys=[댓글수 조회수 추천수 태그수 좋아요수 태그[] 유저태그[] 댓글[] ]
제목,내용,작성자,날짜,태그..는datas소속.

fluids={
'3116'={ 조회수:1, 추천수:5, 좋아요:3, 태그=[], 유저태그=[], 댓글=[] }
'55674''={ 조회수:1, 추천수:5, 좋아요:3, 태그=[], 유저태그=[], 댓글=[] }
...
}
태그=[태그1,태그2,태그3..]
유저태그=[태그1,태그2,태그3..]
댓글=[ [작성자,내용,날짜], [작성자,내용,날짜]...]

튜플은 js변환오류생길위험이라안씀.ㅇㅋ.

정보란 의미에선, 유저태그에 기여자명을 넣어야 해.매우 합리적이지.

해당사용자가 한 일..
유동이판치는건어떻게하라고

로그말인데,보기좋든말든 이걸 쓸 게 아니잖아. json이라는 개념만 유지하게하지싶다.
열람용으로 내뱉기 를 하게 하지,뭐.ㅇㅋ.훌륭하네...2개 나오겠지만.

            [
                "니코",
                "밥먹고싶다",
                "2020.10.30 00:08:12"
            ],
아..정말 아름다운 형태다..

addtag
addtagu
addtagm
으로할까싶은데? 역시태그는기본으로두고
유저태그에
뮤슬람태그를 m으로지칭. m의강렬함때문에동의가능함.
온오프하게하자..신고들어간건거르게하고.ㅇㅋ.. 미친듯신고하는사람이 있으면,트롤이니,해방한다.

>>> subcomm('우미','55','언제는그랬냐고')
list.remove(x): x not in list
False

'우미','55','언제는그랬냐고'
['우미', '언제는그랬냐고', '2020.10.30 03:21:39']
아하 그럴 만 하네.
fluid[no][key].append( [user,text,time] )
fluid[no][key].remove( [user,text,time] )

인데 타임을 어처구니없게도 조회해서간다. 허;
타임은,,별개로딸린부속물로둬야하려나싶음.
키로만접근하게해서그걸지우게해야지
그게키인가;

타임이 달라서 생기는 문제군.
subcomm(유저,번호,텍스트)
만으로 지우는게 가능하려면,
같은내용은하나만존재해야해.
..간단하네.태그랑같은규격으로하지뭐.
ㅇㅋ.논리에 앞서서.
..좀이상한데

fluid[no][key].append( [user,text,time] )

fluid[no][key].remove( [user,text,time] )


태그지우려면현재
로그열어서
addtagu한걸 쭉 뽑아냄
그걸보유한채로,누가했나를감지해야함.
되게힘드네.

	태그에도 작성자명을넣자.이것과 댓글둘다 감춤이필요하다.
너무간단한거였네.ㅇㅋ..
둘이가능한 형식같게하고.
태그엔날짜불필요.댓에는필요.
	..태그에도날짜필요.그래야,최신반영된태그순정렬이라는 오진기능이 가능하다.ㅇㅋ.
	최신달린댓글순정렬도,현재는가능하지.ㅇㅋ.

fluid[번호][태그]
fluid[번호][유저태그]
fluid[번호][뮤슬람태그]

fluid[번호][댓글]
fluid[번호][뮤슬람댓글]
ㅇㅋ.

흠 이러면 태그나유저태그나 모두 규격같게해야지.
당연한소리다.ㅇㅋ.

리스트 버리고 dict로갈까 싶은데..?
태그는유니크하다.
댓글내용은유니크하지않은게좋은데..흠..

fluid[id][댓글] = {댓글1:[내용,작성자,작성일] }
fluid[id][태그] = {태그1:[내용,작성자,작성일] }
..뭐야이게다야?
작성일:은진자좀아닌거같애;

태그는중복불가니,현재구조로 ㅇㅋ.
ㅇㅋ동의함.구축완료. [0]은내용인걸로.ㅇㅋ. ()는자료형깨지니까.ㅇㅋ.
댓글은..댓글1: 이라는 키 값이 되게 모호해진상황.
이걸 댓글내용으로하면 완벽한데, 내용이같으면안된다니.. 뭐나쁘진않네만

자자.이쪽은 규격맞춘 또 다른 우수함이 요구되니까,지금하기부적절하다고주장함.

이렇게,
정수 다뤄지는건ㅇㅋ고,숫자하나니 간단하지.

태그,유저태그,댓글
이 모두 지금 최적화랍시고 달랐는데,정보량줄이는게사실목적이기도했다만
그냥 포기하고 일관성을갖게 맞추자. datetime도 꾹꾹 다 눌러넣기;
정보는 소실되면 그대로 없는거고 역추적이요구되니 심히 곤란한거고
댓글순,태그추가된순도 있음 매우 즐거운것이기도하니까.ㅇㅋ.인거에요.

시간을 함유하게하되,부속물로만취급할까싶고..

시간자체를 정수키로쓰는것은 썩 고려가 됨... 인데 정작 서버컴퓨터측일이라 접근이불가능함.

내용이 유력한 키 값이다. 매칭이 정확하고, 키 자체도 이미 정보를 가지고 있고.
태그는 기본적으론 key만 내놔도 쓸 만하기도 하다던가.

태그간이동은안되겠지..?

댓글에대해,꼬리표가 달리도록 해야 해.그래야 분류가 가능할듯.

뮤슬람태그={ }...인 경우,
유저태그={}에서 저기로 넘어가긴 힘들지싶다.안되는건아닌데..
유저태그{} 에선 결국 아까 안하겠다고 한, 뮤슬람=1 같은걸 해야하나??

글에는 속성부여가되..나싶다.ㅇㅇ. fluids[뮤슬람지수] 를둔다던가.

오전 1:20 2020-10-31

뮤슬람태그라니!
뮤슬람댓글도 있어야 하나?!
..괜찮은데??

글은,이미지가교체되며..인데..
너무 지저분해 지지 싶기도 해.

논의는많은데,추가방식으로하자.

1. set말고 reset을 걸어서 추가변수반영. None 으로 집어넣기라던가.
근데 if [] ==!None: 이랑, if[].notexist 랑 그게그거같다.ㅇㅇ.
뭣보다 noexist함수마냥 갖출수도있고.
데이터베이스논리상,최소자료량정책에 따르면 부적절함.
없으면 false를 반환하게해서, 없답니다,없네요.없으니없음ㅇㅋ
를 처리하게할까싶다.

......책 읽고 싶다. 2일만에 모든 걸 마치고,월화 있다가 수요일에 돌아오자.ㅇㅋ.
오전 1:53 2020-10-31

fluidset하고이후에 추가하도록 하지.기본은 없으면 추가고.
덧셈연산을 수행시, 지금은 이미 있을거란 전제하에동작함.
하지만! 바로하는게 fail뜨면, 존재체크를하게하면돼.그게 대부분의 연산에 매우 효율적일것.
그렇다면, 이미 있는지를 모르는채로 선언하는경우가 크게 문제가 되지.
addn 할거면, 그게 있다는 확신을 가진 채로 수행해야 해.매번 체크 할 순 없어.ㅇㅋ.
즉, 매번 iterative item 추가를 하게하자.ㅇㅋ.
빨리.2일!

댓글 태그 외에는 글 안에 접근이 불가능하다.ㅇㅋ.
태그명을 캐릭터태그로 바꾸자싶음. 동의는함. js가 너무 거대해서그렇지.

canaddtag는 소멸한다.ㅇㅋ.

fluid[id][댓글] = {댓글1:[내용,작성자,작성일] }
fluid[id][태그] = {태그1:[내용,작성자,작성일] }
넘버링으론,지울 수가 없..진 않아. 2중 루프라 그렇지 고려는 가능 함.
태그에도 작성자.ㅇㅋ.매우동의.

addcomm(user,no,text):
이것만으로접근하게하는게매우좋아. 이게 고유 키라면,,
내용으로접근하는경우 키값을 입력하기 심히 더러워진다.
추상화 한번 더 해서, 그냥 리스트로 두고 중복추가하되,
굳이 태그만은 중복검출하게할까싶기도 해.
애초에 목적이었던것에비해 태그댓글이 역할이 다르..기도한것같고..이려나.

글 하나에 대해, 텍스트가 존재하고, 유저명이 기록되어있고, 시간이담겨있다..

태그소트빨리하게하려면?

최근태그달린날:
최근댓글달린날:
흠.썩 좋네.활동 자체에 대해 최신반영이 가능하게 됨. 매우동의.ㅇㅋ.
별개항목으로 넣자. 논리상기능하고, 심각한 연산구현을 안 해도 되게됨.매우편하지.
아니면:
for nolist
  for fluid[no][댓글]
    max( d[일시] )
  dattimelist.push(   )
이렇게되려나.나쁘진않네.동의함..이라기엔 너무 더러워.ㅇㅋ.최근수정일마냥 넣자.ㅇ.

수정일: 도 넣게 하지뭐. 이건 정말 차차.지금 급히 하고파.ㅇㅋ.
2일동안 하고, 간다!!

fluid[no][댓글][내용]
fluid[no][댓글][작성자]

addtagu(user,no,text)
no글에대해, user가, 


잠만,입력갑 user no text보다, no, user, text로 하자.ㅇㅋ그게나음.논리적이고 합당함.ㅇㅋ.
입력받는순서문제니 통일가능.

리스트면 차라리 포문돌리긴좋음.
리스트면 중복도 가능함,,근데 접근문제가 있지.
지운다라는 역접근을 수행하는게 ㄹㅇ 안 됨.
for i in datlist:
if i[0]==user and i[1]==text: subtag(no,user,text)
유저에텍스트같은게 지워지는건 된다만..
댓글번호 라는 정보가 더해져있겠지. 그래서 그 번호에 대해서 지우기를 요청하는걸거야.

로드댓리스트:
datlist=[]
for i in fluid[no][댓글]:
 datlist.append(i) # [user,text,time]
인거겠죠??

for i in datlist:
 makecomm(i,frame)
식으로 들어가겠지.매우논리적임.

아.애초에 그냥 js에서 no를 다 받는구나!아하!!!
ㅇㅋ.
그럼리스트야??
태그가 애초에 중복허용안하는게특수하긴했어.
관리면에선 근데 정보가 다 있는게 좋지.
태그에,큐레이터정보를 보는것도 나름의 즐거움이니까.

태그 올린다 라는 기록이 많은 사람은, 인기 큐레이터가 되어서,
그 큐레이터에도 좋아요나 싫어요가 붙는거고.

댓 차단.
댓리스트:
if loginuser.muslam==True:
 if fill fulldat()
else: fill alldat()
이라던가..정확히는 아무튼 가능해.ㅇㅋ.
댓글은 이렇게 처리 완료.굳이 뮤슬람..댓글이아녀도되겠네. ..?
뮤슬람리스트: 가 있어야하나?
구조상으론 좀 이상하긴 하다.흠.
댓차단이면 1.댓리스트전체로드, 유저스테이트==
user.속성 =[뮤즈,니지동] 이게하려나.흠..아냐. 내가원하는건 극성뮤슬람이야.
계정에 낙인을 찍어야 하고, 그사람이쓴건 안 보이게 해야해.
이러나저러나 배제리스트는 필요하겠군.ㅇㅋ. 인간명부를 만들어두던가하고..차차할일.
지금은 생략하거나,,
근데댓 막달리면 걷잡을수가없겠지.
모든전제는 사용자가 양심껏 배분을 해 줘야 하는것이야.

[댓글][내용]={,유저,시간}
은 진짜아님.내용으로접근이라니.근데되게현명하긴하고
keys가 매우,매우의미있게된다.직접접근가능.
태그면 이렇게 동작해야해.
fluid[no][usertag][

전역태그조사자를 만들까? 파이썬에서훑지않게하고??

아니면 실시간으로 플루이드던져지는걸 받으면 처리하게할까.

태그리스트는 만들어져야해.
태그리스트={ 웃다:[no,no,no...] ,}
태그목록제조용.ㅇㅋ.

뮤즈리스트는..기억이가물가물.

유동으로댓남기게하면, 댓글에 드립치는걸 막을수가 없어.현재는 그런 상태야.
어쩌지?

전역조사를해서,일부에게만보이게해도, 유동은 쓸것이야.
악의적으로 계정을 만들어서 저쪽에 쓰는 것도 가능 해.

계정제로하게하자.현재는 그게 유일한 통제기능.
사실상 바로되는거니까 더욱 더 그럼.
이름주문 미친듯 바꿔가면하는경우는..
전역로그에서수동분류
사용자가다운버튼누르기

...자유를 표방하는 입장이었는데 검열을 하게 될 줄야..

뮤슬람모드만들어서,그안에서놀게하고
유동댓글은 가능하다.실제로동일하고. 다만 지워질걸각오하고,배려해달라.
로그인시,나는극렬뮤슬람주의자입니다[]버튼을 만들게 하지 뭐.ㅇㅋ.

ㅋㅋㅋㅋㅋㅋㅋㅋ
가입시, 리캡챠를 두자.
취향 수집 및 반영을 위한 조사입니다: 해가지고 9개의 관문을 통과하게 하자.
당신의취향은... 하고 쨔잔 해 주고,그럼 가입완료.자동가입귀찮은것도 방지되려나.
그 과정이 하나의 관문이자, 넘 재밌는거로 하게 하자.
되게 재밌을듯. 도전이야.
뮤슬람으로 분류된 사람에겐 on/off를 두기보단 그냥 무조건on으로할까싶다.
대댓기능없이하고.
dict로해서 중복댓없게하자.ㅇ.그게매우빠름.아주빠르지..가아니고
ㅇ러면 너무길어짐,키가.매우드럽다.
그냥 리스트로 해서 넘버링으로하자.ㅇㅋ.태그만 중복거르고.ㅇㅋ.
댓은 리스트순회할일이 많아.ㅇㅋ.
태그는,,
태그도결국 루프돌려야겠네?ㅇㅇ.애초에그럼.ㅇㅋ.
[태그]= [태그1,태그2,태그3...]
이었는게만족스러웠는데..
ㅇㅇ리스트라서,최신이 자동정렬됨.그게매우좋아. 새로추가된태그 가 나오네.ㅇㅋ.
..뭐 dict여도그렇지만.

-태그로드나,댓글로드나, js코드를 같게 하자.그게 핵심이야..!

전역태그리스트는 필요하고, ㅇㅋ.
조회수리스트[no..]
추천수리스트
좋아요리스트
댓글수리스트
태그수리스트

최근댓글리스트
최근태그리스트

fluid[no[좋
으로 정수는바로접근됨.
태그수도 태 로 하자.ㅇㅋ.
나머지두개가문젠데..

최근댓글리스트를 알기위해선,
매 가장마지막 댓글항목의 데이트를 접근해서,보면되네.어렵진않고..
const lastItem = colors[colors.length - 1]
댓글 = [유저,텍스트,타임]
fluid[no][댓글][-1][2]
이구조면 우선 댓글에 하위항목붙어도 괜찮아. 댓글 자체에 대한 추천수도 부여해야 좋지.
댓글 = { 1: 댓글1, 2:댓글2}
댓글1 = {유저: 하나요, 텍스트:어제뭐했노 ,타임:20200520038302}
풀 딕트로 갈까 싶다.


for i of keys( fluid[no][댓글] ):
   fluid[no][댓글][i][날짜]
이렇게됨.큰문제는없다만..
..진지하게괜찮은거같은데요
key 리스트를 생성하게되는게 좀 느리겠지싶다만, dict형태를 어떻게든 보존하니까 좋아.

fluid[no][댓글][ fluid[no][댓글].length-1 ][날짜]

function 최신댓글날짜(no)
	fluid[no][댓글][ fluid[no][댓글].length-1 ][날짜]
가능함ㅇㅋ.dict ㄱㄱ.
리스트의 유용함이라고해도, 그거뿐이었는데, 그냥 i번째를 키로 집어넣지뭐.
dict형태를 유지하는게 더 낫지싶어,빠른접근을위해서..
for i in list
    i
for i in dict
   dict[i]
로,정말괜찮다. ..진짜좋네?
ㅇㅋ.
입력이 1줄로안끝나는게 심히 귀찮긴 하다.
아니근데왜dict여야해??어짜피 인덱스 쓰는거?? 심지어 문법도 같잖아.

태그리스트는 평행하게 더해진다,체크만 거치고.
댓글리스트는 평행하게더해진다,더해진다. 튕겨나오면 타임이같은거임.ㅇㅋ.

너무간단한데. append한줄의 유용함을 버릴순없다.현행2행체계를 유지한다.ㅇㅋ.
아주빠르게.
오전 3:08 2020-10-31

캐릭터태그: 를둘까싶은데, 기본태그명령이있으니 ㅇㅋ하고 진행한다.ㅇㅋ.
어쩌면 애초에 유저태그없는게기본이니까.ㅇㅋ.

최근변경된태그날짜:
vs
fluid[no][태그][-1][날짜]
ㅇㅋ.이걸로간다.직접접근하도록하지.

오전 3:10 2020-10-31오전 3:10 2020-10-31오전 3:10 2020-10-31
논리가단단해짐.리스트만은유지.ㅇㅋ.dict는안쓴다.매우깔끔해짐.

dict쓰는큰이유가 댓글의 접근값이었는데 지금보니왜그랬나몰겠다.

작성자,내용,날짜.필요시추가하되.
추가시 형태단단하게하기.
근데 태그리스트,댓리스트는어쩔수없지;ㅇㅋ.이해함.

로그엔 현행유지?근데가독성이핵심인데 그게조져지니;
파싱을하자싶다만, 1월 11월 분명차이남.
문자열넣어도 텍스트라서 곤란하지.
절대안쓸만한문자열을넣자싶다만,그거론안됨.

로그랑플루이드 이름섞인다.어카지?
fluid_b1.json
으로가야지싶어.
귀찮지만 합리적임.ㅇㅋ.

json저장옵션은, '그래서\"어'쩌\"라\"고'요'
식으로 안에있는건붙고
'' 안의 것은 죄다붙는거같은데,애초에그렇지않나;
로그addcomm('33','ko',"그래서\"어\'쩌라\"고\'요")
입력addcomm('33','ko','그래서\"어\"쩌라고요')
ㅇㅋ아무문제없으니하던대로하고,
"addcomm('33','ko','그래서\"어'쩌라\"고'요')",
이게 representive 표기법이다.
"로인해 구분되겠지..ㅇㅋ. .. ???흠
addcomm('33','ko',"그래서\"어\'쩌(라(\"고)\)'요")
"addcomm('33','ko','그래서\"어'쩌(라(\"고)\\)'요')",

코드처리하긴 리스트가 압도적으로 좋다.
근데눈으로보긴인데
텍파를눈으로본단건있을수없다..아닐까?
a="하나요는언젠가말했지,')"
세이브후로드함
c[-2][0]
"addcomm('33','ko','하나요는언젠가말했지,')')"
exec(c[-2][0])
에러.

'하나요는언젠가말했지,')'
를 수행할 순 없어.

이건 로그니 차차 하자 싶다.
인젝션을막기위해,, ()를 대체저장할까싶다..만 괜히이상하려나싶고.
여기까지와서 sqlite를 썼어야하나..?싶기도. 로데이터가 그대로가니까.
완벽히이해가능한 '이란 내 정책과 다르니뭐.ㅇㅋ.

인젝션은 일단 파이썬내부에선 str취급이니전혀문제없고
로드하는경우가문제된다.

a= "나요는언젠가말했',)지,"
>>> addcomm('33','ko',a)
True
쉼표도문제고.

"addcomm('33','ko','나요는언젠,가말했',)지,')"
>>> exec(c[-2][0])
에러.ㅇㅋ.

'addcomm','33','하나요','글내용'
으로 저장하게해야겠다.그게훨나음.
이런거다 낭비아닌가싶기도하고.

ㅇㅇ감싸는거는 어떻게든 str거치며처리됨.

>>> 
>>> c[-2][0]
'addcomm(\'33\',\'k125o\',\'나요는"언젠,\')'
ㅇㅇ 이게 어떻게든 str로 들어가서 그래.이걸 []로 각개저장하자.ㅇㅋ.
로그에기록남기는걸 그냥 자료형자체를 저장하게하고
그걸 재조합하게해야겠어,애초에 txt로 그대로 문자열갖고 긁어서복원하려는게말이안됨.ㅇㅋ.

하나의 믿음은, 그건 그대로 저장된다였으니까 말야.ㅇㅋ.

logue.append( ["subtag('{}','{}','{}')".format(no,user,text) ,time] )

를,
log(no,user,text,time)
으로.얼마나간결하니..
아.아니다.더간결했다.ㅇㅋ.

logue.append( [whatdid,no,user,text,time] )

subcomm(no,user,text)
이거어쩔래

def subcomm(no,user,text):
for i in fluid no key:
if i[0]==no and i[1]==user and i[2]==text:
EXECUTE!

텍스트가 같은게불가능하게하지뭐.그럼해결됨.매우강력하군.
아.이거 애초에 유저 삭제 안 돼.ㅇㅋ.
근데지금구조면삭제도됨.대댓은없어요!

그리고,투고 창을 열어 놔야해.개선점:같은거.ㅇㅇ..
이제 또 관리개선점, 유저개선점
이 기록되려나..하..


https://stackoverflow.com/questions/33162319/how-can-get-current-function-name-inside-that-function-in-python/33162432
오.로그남기는것에대해 되어있음. imp[ortlogging

addtag(no,user,text, key='유저태그', num='태')
하게 할까?
오전 4:10 2020-10-31
자자.

명령이,매우지저분해집니다.ㅇㅋ.

일단갖춤.이게끝이냐싶은데,끝이다.

소트용태그리스트 구하기 함수는 만들어야겠다

댓글수..등 정수는ㅇㅋ
	코멘트.
신고받으면,뮤슬람전용으로하게하기.ㅇㅋ..인데, 필요시 회색열람하게해서,아닙니다!를하기.?

뮤슬람계정이 댓글쓰는모든게 감춰진다면 안돼.매우.

댓정렬은 날짜로한다지만..
이렇게 되면 그냥 댓글에 다 몰아두는게낫지싶어..
구분은어케하게?계정은너무하지?
나는극렬뮤즌데 클린태그댓글하는사람이고

나는극렬뮤즈고드립친다.. 이경우엔 뮤슬람=1 버튼을 누르게하지싶어.
아니면, 직접 스스로 그 댓글에 -1을 하던가.것도좋네.

진영을 선택하게하고
해당진영의글만 깔끔히 보게 할까?
같은진영끼리만보기 버튼을 두는거지.

아.역시 댓글이랑 태그 속성 달까 싶어.

댓글에,댓글규격이 지금
fluid[no][key].remove( [user,text,time] )
log(whatdid,no,user,text,time)
인데
사람이,뭐라고,언제남김
이잖아.
사람이,뭐라고,언제남김,진영속성
을두는거지싶다.

이러면 전통적인 노,유저,태그 가 깨지긴 함.
궁극적으론 태그나댓글이나겠지만..점점이상해질수도.
태그랑댓글은다르지;

가입시,
진영을선택하십시오: /vs..해가지고..
다른쪽의 글은 볼수없습니다.소통도 불가.
회색지대로 가입할수있습니다.그 경우, 보고 진영을 선택하세요.
와...오진다..

1.태그는 중립기여적용됨. 다만자체동의를거쳐거르도록??
2.댓글은기본적으론안보임

이라던가.

사용자입력은 태그와 댓글이 유일하다.
태그는솔직히 아예 존재조차 안보이는게 매우 합당하다고 여겨짐.
태그는 둘다보고싶으면 둘다보는게된다. 각자가 좋아하는것에 기여한거니까.ㅇㅋ.

댓글은 

흠 아니면 그냥
이게또그런게 물자이크없는버전은 분명 댓글이 뻔하다고.
아예 글자체를 분리해야겠음!!썩 동의함.
정확히는, 보여지는댓글자체를분리해야지.!

@#%@#*%^ 막 이렇게되어있으면 개꿀잼이구만;ㅋㅋㅋㅋㅋㅋ
언어가 다릅니다

회색이 다는 댓글은 내가 안 보고싶다.. 만 누군가 뮤슬람이 내려버리면 안보이게하지뭐.ㅇ.
아니면 보고싶은사람이 ㅇㅋ하거나.


그냥솔직히,뮤즈온리페이지가 있었으면 한다.니지동도 안 보고싶으니.
그안에서, 과격파,온건파가 나뉘는데

흠..

오후 2:08 2020-10-31

태그제조중.통일된규격.
심지어 댓글도 같이 처리해버리기.
6개 명령 관리하기 귀찮고 힘들다.
요청도 동일하게들어감.

정수 조회수등은, 이력으로수정가능하게했고.


[댓글수]=3
보다
len( [댓글] ) 이 낫지 않아??ㅇㅇ삭제해도될듯.개념적으로 불필요하지싶다만.
js에서 고속탐색하는게 목적이었는데, 이게 이러면 구분이 이상해.ㅇㅇㅇㅋ.
ㅇㅇ.그리고 텍스트기반의 자료들을 모두 같은포맷에서 관리할수있으니.
조회수등도 뭐 그렇게하는게가능하겠지만, 그러면 덩치가커지니별로.ㅇㅋ.

추천인목록
좋아요한사람목록
조회한사람목록

은 어때?
..아냐.ㅇㅋ.
근데 결국은 그게낫지싶긴 해.

현재는 플루이드의 연산이 제한우려됨..하..

작년 5월 25일부터 시행한 유럽연합(EU) 일반개인정보보호법(#GDPR)이라는 규정
쿠키.

소트리스트

조회수순
좋아요순
추천수순

댓글수순
태그수순
요청수순

최근달린태그순
최근달린댓글순
최근달린요청순


조회수를 그걸로 안 할 이유가??

length(fluid[no][조회])
로 된다.ㅇㅋ.정수연산파기.후후후..

...조회수는 중복허용되는거아냐??
정수들.

연산속도면에서 조회수는..싶기도 해.
추천수는,로그있으니 역추적가능하다였는데말야..

추천리스트에 사람이 뜬다면..흠..
중복허용:
중복비허용:
의 두개함수만들까;

정수를따로관리할까싶기도함.흠.
일단은 중복체크는 태그댓글에만적용하게하고

하 그냥 중복 체크 온오프해야하나

중복체크 ㅇ면 중복체크하게하고.이건구분해야겠어.ㅇㅋ.
텍스트입력은 모조리 중복 없게 하고.
그런경우,이미지콘댓글이 있는경우 대체 어떻게하지..
이미지를로그하게하고
애초에삭제명령때문인거아냐??
text를 해시아이디로 넣자.어때?

애초에그리고 딜리트명령은간소화가필요하지싶고..후우..
애초에 로그복원을 텍스트로설계하려했던게문제야.ㅇㅋ.

로그무시하고다시재설계해보자.

번호,유저,대상,내용
+시간이 붙고.이게전부아냐?
댓글에,댓글내용
조회수에,조회수추가됨
태그에,태그추가함.

입력: 번호,유저,대상,내용
로그: 번호,유저,대상,내용+시간
저장: 유저,내용+시간

삭제: 삭제를 ,유저가언제한그이벤트 라고 하기보단
삭제: 번호,대상,유저
혹은
삭제: 번호,대상,해시

로 하게하지싶다..

시간을 그냥 그걸로 두지 싶어.어때.
삭제: 번호,대상,유저,내용+시간

기억났는데 애초에 이거 정수연산하겠다고로그남기고 역연산하려했던거야..
로그에서 해당인간을 죄다추출.
그중에서 체크하는걸,삭제.ㅇㅋ.
삭제는,해시값으로바로들어갈까..?
del fluid[no][key][hash]
얼마나좋니..!

리스트에 인덱스를 붙여두자.그럼되는거아니야??

for i in dat
make(i)
i= {작성자:내용:일시:해시:}

ㅇㅇ 로그에서 다시 최근 추천..이건진짜아님.
모두 공통규격을 갖게 하고.
내부자료구조는그렇게갖추되
[댓글1,댓글2]
가 있는것에서 순차접근하는게아닐까..?
리스트라면 리스트니까.
이걸 {}로 키-밸류로 하며면..흠..

add tag 태그이름 --기타정보
이걸 지우려면 어케하지?
del [no][tag]['태그명']
이 되겠지.

del [no][태그]['댓글내용']
이면?
del [no][조회수]['댓글내용']

30000바이트, 30키로바이트가추가되겠군, 천글에 30바이트추가시.

오후 4:35 2020-10-31
처리 완료.
리스트가좋은게,어펜드하면 자동넘버링추가였는데
삭제시 답이 없었어.이게고정되려면 키가있어야지.
dict를 쓰자니, 너무 낭비되는정보량에, idx할거면 list쓰지 왜 싶었는데,
고유한 정보량을 id느낌의 순서에 고정해서 접근하게하려면 dict가 좋았던거야.
리스트는 불특정 의미순서집합의 것으로.ㅇㅋ.

https://porkbun.com/products/webhosting/staticHosting

https://porkbun.com/checkout/search?q=aikatsu.com&tlds=&idnLanguage=&csrf_pb=d2ea4b4997980f8a0e96b0d462314cf0
년 8달러라. 썩 좋군.

아...그냥안지우면되는거아니야????
0,1,2,3,4,,,,,남고
추적시엔,그냥,,은아니고 고유번호는있어야 해.

visible=0,1,2 0은보이고 1은숨김 2는삭제
흠.괜찮은데..
정신 나갈것 같다..

글
번호1에대한 글이니까 csv로는 대응이 안 될듯..?ㅇ.

리스트만빼꼼있으면 진짜 좀 아냐;ㅇㅋ.
0,1,2,,,인덱스 붙이되
초기생성때 인덱스0을 붙이는건진짜별로고
삭제만 안 하면 되겠지. 그러면 인덱스 0..이 보장되고, len==maxindex 이다.ㅇㅇ.

보임숨김삭제 하면별로고, 이건 정수값으로 두게 하자.
3번숨김같은건 2번사람한테는 보이게해야겠고.그럼될듯. 0,1이 아니니까.ㅇㅋ.기본정립이렇게완료함.
오후 5:32 2020-10-31

글이생성되고..부터 시작일것같은데말야.
뭐 어때.ㅇㅋ.

댓글목록에서,삭제한다치면..
1.전역댓글발생감지기
2.해당글에서확인- see를 3으로 설정 함.ㅇㅋ.내부값이니반영되겠지.간단하네.해결!!ㅋㅋㅋㅋ

짤 하나에 대해서는..? 지금은 규격 같지.응.
글이니까이것도.ㅇㅋ.
느리려나;설마.ㅇㅋ.
아무리그래도 무슨짓을해도 네트워크지연 44ms보단 짧을거야.

짤 자체에 대한 판별은 어떻게 하지??
지금그게그거군.ㅇㅋ.

짤은
슬라이드쇼, 모자이크리프레시등이필요.ㅇㅋ.

오후 9:15 2020-10-31
다시 마음 잡고.

idx = max( fluid[no][key].keys() )+1
이게 핵심인데, 리스트가 선언된이상 길이반환되는것처럼
dict도 그래. 키값자체는 의미없지만, 입력된번호인것이야.ㅇㅋ.이걸로 가자.
구조상 1부터 시작함에 유의.

fluid[no][key][idx] = { user: text: time: see: }
를 해서 숨김처리를 하게 하자.
삭제도 가능한 구조이고, 삭제시, 삭제될 뿐.인덱스로될뿐.

이력에, 기록시의 idx가 남을테고.

오후 9:28 2020-10-31


