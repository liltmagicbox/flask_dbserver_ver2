오후 2:10 2020-10-29
이관함,덮어쓰냐문제로부터.

우선 딕트부터 만들자.
플루이드 내놓기로했고,매우훌륭하고..

현재 되는게,고정사용하는
제목순정렬,날짜순정렬.ㅇㅋ.

필요한건

조회수
추천수
댓글수
.
제목은 특이하게, 내장하고있을텐데싶다. 흠..js가진짜안느린가;
그럼같은논리로.ㅇㅋ.


조회,추천,댓글 모두, 지금한다해도 뭐 볼수가 없다.나중에구축하자..
동의함.

태그입력기.기초적인 뮤즈태그부터 가능하게하는것.

본문뷰어. 본문을보면 조회수,추천수,댓글수 들어간다.근데 태그보기도해야함..흠..
간단힌 이거먼저하기좋네만, 분위기상은ㄹㅇㅇㅇ.

본문보기요청이,현재 지금 datas에 본문을띡가져오는것이고,ㅇㅋ.
no,본문
으로 가져온다.ㅇㅋ.
datas하나에서,미니datas를만들어서,그걸던져주자. vs
fluids에서 따로가져오기.

본문로드시
ㅇ본문
태그-없다!입력기필요

댓글들..저기서쓰면,여기서받는거네.ㅇㅋ.가능. fluid에저장됨.
추천버튼은 저쪽에서 요청해야함. 추천되면 fluid 에 저장됨.

이다.이게젤어렵다.

fluid의핵심을구성하는 태그부터 만들까싶다.
s붙이기귀찮으니 fluid로감.ㅇㅋ.유체니까.

fluid를구성하고, db와별개로 순수json으로 구동된다. txt만 접근하게됨.
db는 getjar, 등을하는거였으니.원래른그랬는데,모듈만로드해와서
결국 서버메모리에상주시키는게현재설계였지.ㅇㅋ.

db에서 넘치면 저기로 모듈로빼내면되고.ㅇㅋ.

fluid{}있고,

fluid[no]['조회수']+=1
매우잘됨.ㅇㅋ.
심지어 이걸 js명령으로 기록하는것도되겠네.오오.. 아냐 js. 파이썬이야.ㅇㅋ.;

조회수는어처구니없게도 이렇게 완료다.ㅇㅋ;
1.조회요청시,2.조회수+=1함.3.종종 조회수소트리스트 를업뎃함.ㅇㅋ.
2추천요청시,추천수+=1함.종종추천소트를업데시..

3댓글작성시,댓글수+=1함..?흠.하지뭐.ㅇㅋ.근데1줄차이다.하지말자.ㅇㅋ.관리대상2개니.
3-댓글작성시,플루[넘][댓].append( 댓글내용) 한다.진짜오지네ㅋㅋㅋㅋㅋㅋ

4.태그입력시,플루[넘][탯].append(태그내용)한다.진짜오지네ㅋㅋㅋㅋㅋ
논리가같다.최고다.
태그입력기도 동이랗게가고 태그는근데계정명이필요함.동의하공.어케하지?
유저태그[1,2,34,,] 는 이름 붙이지 말자.ㄹㅇ그냥이대로두고
로그에만 기록해서,요놈녀석하고 지워버리게하자.ㅇㅋ매우동의함.
큐레이터도아니고말야.큐레이터면의미있지만.. 그건 로그에서따로내자.너무더러워져.
논리가얼마나좋니 ㅣ니ㅣ니ㅣ..아니다니!!

댓글도동이ㄹ하게 입력자 구분해야함!
댓글 = [   [작성자1,작성시간,댓글내용] ,  ... ]  ㅇㅋ. 이이상일필요없지?
ㄴ근데구조상으론 json이낫네.
댓글 = {  작성자1:[시간,내용] , ..} 동의함.ㅇㅋ.ㄱㄱ.
태그 = [  작성자1:[태그내용]도,
태그 = { 작성자1:[태그1,태그2,...] ...}
ㅇㅋ큰차이없.

근데,사람이했단게..그렇지뭐.로그를보면

fluid[no][tag]['니코'].append(과식)
이 되겠지.진짜좋네.. json으로유지되는게멋짐.
logue신설.ㅇㅋ.

로그는 []가낫나싶어.순서가 json은 없으니까.바로접근하는키지..
로그이력키를 두자면어떨까싶긴해.인덱스+=1을해야하지만..
keys로내놓나?
len으로내놓지!흠..이러면 그거위배되긴하는데 일단됨. 1234 6이면 6 덮기전엔계속됨..
그리고 더 늘질 않아. ..? ㅇㅇ 그게없으면. 키가위에훌쩍있으면.
근데논리상절대안무너지겠지싶은데요..

max(list(a.keys()))
로얻을순있지만..별로같긴하지.개념상은이게맞지만.

앷에근데접근을안하니까..흠.
ㄴㄴㄴ이건 ilst가..아.그거랬지.ㅇㅋ.. json바로저장과 바로이송이 얻는 혜택이라니.
미쳤지만 그런으미ㅣ에서괜찮으니 이렇게 ㄱㄱ.
[
    1,
    2,
    3,
    "ha",
    "11"
]
리스트합시다.ㅇㅋ..
뭐 아주잘되네요.ㅇㅋ.
시간순으로적재되고 인덱스가 0부터나가고 관리쉬우니 ㅇㅋ.
로그는 list로,json형태로쓰도록함.ㅇㅋ.
어처구니없이잘됨.ㅇㅋ..
명령어를말이죠,그대로저장합니다,,그러고반대로할까요?
리스트에 명령이저장되는데요.. addn같은경우는 추천수면, 추천인도 들어가야해.유저도.
유저,넘버,값 으로가지뭐.모든경우에될듯.ㅇㅋ.

로그
유저1이,넘버1453의,키[추천수]에,add했다.
명령자체는 상위명령자체가그렇군.ㅇㅋ.
텍스트로우선복원가능하면그걸로충분한거야,
리스트는 라인으로 txt로얻고빼기가되니.ㅇㅋ.굿.
그래서리스트가좋구나..!

>>> user='마키사랑해'
>>> no=1251534
>>> key='추천수'
>>> "addn({},{},{})".format(user,no,key)
'addn(마키사랑해,1251534,추천수)'
가 된다.이거면되지?

fluid['1251534']['추천수']=44
이렇게 다이렉트어사인은안됨.흠..
fluid['1251534']이게 dict가 아니기때문이지.ㅇㅋ.
fluid['1251534']={}
fluid['1251534']['추천수']=44
안된다!
addn('마키사랑해','1251534','추천수')
>>> addn('하나요','11','추수')
>>> fluid
{'11': {'추수': 5}}
제대로동작함.
jsonlistdump에 실험한게있다.ㅇㅋ.
4
["addn('하나요','11','추수')", "addn('하나요','11','추수')", "addn('하나요','11','추수')"]
["addn('하나요','11','추수')", "addn('하나요','11','추수')", "addn('하나요','11','추수')"]
후후후후.후후후후후ㅜㅎ..입력/출력결과가같다.
[
    "addn('하나요','11','추수')",
    "addn('하나요','11','추수')",
    "addn('하나요','11','추수')"
]
ㅇㅋ.이거면 역연산가능함.
..이랄까..흠..
add의역이 sub이니까 변환하면됨.ㅇㅋ. 이건 하지.
for i in ll:
	print( i.replace('add','sub') )
이렇게간단히될줄야;역시파이썬이좋아흑흑흑
exec()
이거였나..가물가물.ㅇㅇ 스크랩에서씀.
오전 6:01 2020-10-29
ㅋㅋㅋㅋㅋㅋ진짜잘됨. 황홀함에가깝다. 난 , 내존재이상의걸 느끼는거야..
뭐야6시네 자자;

완-벽히 논리적으로적절히동작함.진자 정수다 이건...
그..로그는..
["addn('하나요','11','추수')",
 "addn('하나요','11','추수')",
 "addn('하나요','11','추수')",
식으로있는데요..이러면 누가했나를 검출하려면..
for i in logue:
	if i.split("'")[1]:
	    print(22)
으로어떻게든잘됨.ㅇㅋ..

오전 6:12 2020-10-29
아무튼잘됨

N은그렇게되고,
addn은그렇다쳐도
add면 역연산하고
거뭐냐그거면 그렇게하게하지뭐.ㅇㅋ.일단 유저입력까지도함개꿀이야진짜;

오전 6:18 2020-10-29
자자.곧.

fluid의 키는 죄다 "333"으로처리하도록.명심하자..

fluid['1251534']['추천수']=44
인 식이고, 안은 int여도 어짜피복구하면그렇지않나싶어..흠.
>> cc
{'11': {'추수': 3}}
int네.
{
    "11": {
        "추수": 3
    }
}
ㅇㅋ.그럼 형변환없다고확신하고..
str엔 연산못하는게 파이썬이니 ㅇㅋ.확증하고감.
js에 너무 더럽혀졌어..흑흑.

아그래서 뭐였지..
댓글은,역역산논리가..

dict에, 잘있고요..
댓글 = {
작성자1:[시간,내용] ,
작성자1:[시간,내용] ,
}
뭐야이럼전역댓글리스트잖아.
fluid의 no번의글에 key에서 ..가 아니네.흠..
ㄴㄴ맞는듯.
fluid[no][key][user]= time,text
에서, ()할까 []할까.흠..

도동이ㄹ하게 입력자 구분해야함!
댓글 = [   [작성자1,작성시간,댓글내용] ,  ... ]  ㅇㅋ. 이이상일필요없지?
ㄴ근데구조상으론 json이낫네.
댓글 = {  작성자1:[시간,내용] , ..} 동의함.ㅇㅋ.ㄱㄱ.
태그 = [  작성자1:[태그내용]도,
태그 = { 작성자1:[태그1,태그2,...] ...}

뭐야..태그는[]겠지.ㅇㅋ..

fluid[no][tag]['니코'].append(과식)
이 되겠지.진짜좋네.. json으로유지되는게멋짐.

흠..
계정을둘까요?안둬도 역연산은가능하리라확신함.ㅇㅇ.
일단안둬보자.ㅇㅋ.댓글관 상태가다르니.ㅇㅇㅇㅇ.

fluid[no][key][user]= time,text
이러면 순서가..타임으로되네.오지군;초까지넣고 표기만그거로하지싶다..?너무한데;
key=닷글
fluid[no][key].append( 유저={ 시간:time , 내용:text} )

이건어떄?되게더러워졌으나,논리적이나,더럽다만,[]라서 일단 인덱싱이됨.ㅇㅇ.
댓글순을 len할때같이구해??것도편하긴하네,매번전역스캔은안할거야. 흠.


일단 고민은있으나,
조회,댓,추
태그
의 첨가논리를 구축흐였다.ㅇㅋ.

소트시뭐더있던가일단은ㄴ.

좋아요버튼이 개추와구분될핑료가있을수도.ㅇㅋ필요시추가함녀됨ㅇ.ㅋㄱ꿀
오전 6:42 2020-10-29

태그엔 ㄹㅇ 이렇게하면됨.지우기도쉽고.ㅇㅋ동의.
각명령은 t/f반환하게해서 나름규격갖추고

댓글은,댓글도인덱스들어가니 그리하자.
[댓글].append( {작성자:user, '시간': 오전 6:43 2020-10-29, '내용':'235236236236'} )
[]로해도,지리적이점이라고보기어려우므로.훌륭한구분.ㅇㅋ.
댓도 시간순이의미있다.ㅇㅋ.

a.index('df')
리스트 역추적발견함.오오. ..?이거되게공격적..
a.remove('df')
ㅇㅋ

>>> a.reverse()
[2, 1]
>>> a.sort()
[1, 2]
ㅇㅋㅇ
오전 7:15 2020-10-29
자자..해가..

오후 2:10 2020-10-29
실험데이터갖고.

>>> keys = ['a', 'b', 'c', 'd']
>>> x = dict.fromkeys(keys)
>>> x
{'a': None, 'b': None, 'c': None, 'd': None}
dict.fromkeys(키리스트, 값)처럼 키 리스트와 값을 지정하면 해당 값이 키의 값으로 저장됩니다.

>>> y = dict.fromkeys(keys, 100)
>>> y
{'a': 100, 'b': 100, 'c': 100, 'd': 100}

디폴트선언이 가능하고, None으로 입력되는게 핵심이다. 후..
심지어 지정해서입력도 되네..
새로운 객체를 우선 이렇게선언이되겠어.흠..
지금 알다시피,없으면 --한다 였는데 None채우기가되네.
txt에서체커는 형식검증이었지만.

플루이드쪽이니 여긴 별개의일이다.ㅇㅋ.
키값에 미리 선언이필요하고..없으면 오류나니까.

defaultdict는 없는 키에 접근하더라도 에러가 발생하지 않으며 기본값을 반환합니다. 
defaultdict는 collections 모듈에 들어있으며 기본값 생성 함수를 넣습니다.
from collections import defaultdict  
응 안 해

https://stackoverflow.com/questions/8214932/how-to-check-if-a-value-exists-in-a-dictionary-python
'one' in d.values()
True
..뭐야느린가

디폴트를잡기에 동의함.ㅇㅋ.매우빠름.
디폴트를 이러면 다 []로 잡을까싶어, []면 없단소리니 같은규칙적용됨..

fluid[no]={}
fluid[no]['조']=0
fluid[no]['좋']=0
fluid[no]['추']=0
fluid[no]['댓']=0
fluid[no]['태']=0
fluid[no]['태그']=[]
fluid[no]['댓글']=[]
뭐 이런느낌이겠지. 지금하는게 datas가아니니 저쪽은 무시하고..

플루이드의[no]가 디폴트로 선언되는게 가능할까..?
no가 처음 언급될 때, 선언하는건 가능한데말야.
a in dict.values()
는 너무느려.30ms 이따위임.
..아닌거 같은데요..

10만이라그래!
10만에 4ms걸리고, 2만에 1ms.ㅇㅋ.

if '444' in ddd.values():
스트링으로테스트됨.

fluid..
datas불러와서,그걸그대로집어넣지싶음. ..은큰일..나나..?
1.플루이드에 없고 datas에 있으면,
2.플루이드추가모드 수행. no를 받아서, 디폴트선언한다.ㅇㅇ가능함.
fluid[no]={}
fluid[no]['조']=-1
fluid[no]['좋']=-1
fluid[no]['추']=-1
fluid[no]['댓']=-1
fluid[no]['태']=-1
fluid[no]['태그']=[]
fluid[no]['댓글']=[]
이렇게만해주면됨.ㅇㅋ.
..간단하네.
이게아니고선,어쨌든 addn을 수행해야하는데 암것도없으면안되지,그걸매번확인하는게정말싫은거야.
이경우,datas지워져도 보존되고있고,일치가아니니.
datas더들어오면,그만큼추가될것.ㅇㅋ.

신입 리스트를 그냥 만들까?그게낫나??

-1하면 선언전인데 +가 가능하니 별로같아.
[]로하면, []면어짜피못하지만 그러니확인하면되고.
근데 심지어 0이면 그냥 하면됨;흠.. ㅇㅋ그러네! addn은 무조건사용가능해짐.ㅇㅋ.

오후 3:09 2020-10-29
후.fluiddb 개설함.매우훌륭.매우...

[]더하기성공.
로그에어펜드 실패.
이경우엔, false가 반환되는데, []는성공했으니 알게모르게기록되어있다.어쩌지?
except면,된걸 되돌리고가야해.ㅇㅋ.


def addn(user,no,key):
    k=0
    try:
        fluid[no][key]+=1
        k=1
        logue.append( "addn('{}','{}','{}')".format(user,no,key) )
        return True
    except:
        if k==1:
            fluid[no][key]-=1
        return False

이렇게했다..쓸데없이엄청길어져버렸군;

def addn(user,no,key):
    k=0
    try:
        XXXXXXXXXXXXXXXXXXXX
        k=1
        YYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
        return True
    except:
        if k==1:
            reverseXXXXXXXXXXXXXXXXXXXX
        return False
인데말야.

그리고,except수행중 에러나는경우는 곤란하다.
ㅇㅋ.
흠.간결하게함.2줄더줄임.

def addn(user,no,key):
    try:
        fluid[no][key]+=1
        k=1
        logue.append( "addn('{}','{}','{}')".format(user,no,key) )
        return True
    except:
        if k: fluid[no][key]-=1
        return False
명확하고,한줄이다.괜찮아뵘.. 여기선 직접 값 연산이라 이게오류날까싶기도하고.이전에되었는데
여기서안된다고??가힘들지싶다..

subcomm(user,no,text,time):
에선,댓글내용을 보존하고있어야하나??시간하고??
흠..
ㅇㅇ당연.ㅇㅋ. 지울거면, 읽어서,집어넣으세요.
근데이런경우가있을까싶다..금융도아니고 원;
아니,값은했는데,로그에 기록못하는경우가.... 충분히있다.ㅇㅋ.
logue.append( "addtag('{}','{}','{}')".format(user,no,text) )
에서, 아무튼새로추가하는거라서 명령자체가문젠안되나,
1.[]가 쓰기잠금걸림
2.유저명이 이상한거라서 규약위반 ..?
유저명을 str로받게만하면 절대문젠없겠지싶다만요..

일단은믿고가자,솔직히진짜아닐듯;
2중루프는고려가능한데..ㅇㅋ넣기.
..보기더러워진다.흠..

1.태그지우고,오류를내게되면,, 태그는없어졌는데 로그는..하..
ㅇㅇ정신나간일이야.이럴거면 
i+=1
if i_before == i: i-=1
이따위로해야하잖아.어휴;

ㅇㅋ.
일단 좀 위험하게간다. 태그뺐는데 로그에 안 남거나, 태그=[1,2,3] 태그수=2인경우가 발생할것.ㅇㅋ.

오후 3:41 2020-10-29
잘하고있었고

def getJson():
    global datas
    jsonName = 'datas.json'
    datas = minidb.loadJson( jsonName )
    return 'getjson'+str(len(datas))
에서, global 선언이 필요할까???
서버에서 돌아가는 datas란게 유일하잖아.
아마도, 일단 main일때 ..아..main이 아닌가...

웨이트리스에서 부르니까 그럴 수 있겠어.흠..
app = Flask(__name__)
@app.route('/')
def hellow():
   return 'hello'
흠..
@app.route('/get')
def getJson(datas):

이럴순없으니까 그런거아닐까싶은데..
좀 이해는 되겠어.ㅇㅋ.

@에 딸린건 글로벌변수를 끌고와야한다고생각해.

@app.route('/bodyload')
def bodyload():
    global fluid
    tmp = fluid[n][key]

식으로말이지..

def addn(user,no,key):
    try:
        fluid[no][key]+=1
        logue.append( "addn('{}','{}','{}')".format(user,no,key) )
        return True
    except:
        return False

@app / viewiing...
def view
   ...senddata
   addn(user,no,'뷰')
흠...

@app / viewiing...
def view
   global fluid
   global logue
   ...senddata
   addn(user,no,'뷰',fluid,logue)
이건정말싫을듯;근데이렇게동작하지않으려나;

   addn(user,no,'뷰')

def addn(user,no,'뷰',fluid=fluid,logue=logue)
로 하자..?
ㅇㅇ.동의함.
일단실행해오보.요는 웨이트리스에서갑자기발생시로군.

오후 3:52 2020-10-29
아...app이 클래스라고 가정하자.
app.run() 이니까.

class app .........
@app.route('/bodyload')
def bodyload():

class app .........
    self.bodyload()

뭐이런느낌아닐까.
ㅇㅇ.클래스의 내부 메소드로 할당이되는거야.
그래서,클래스외부에서 끌고오고자 이걸 쓰는거지.
그렇다고 app 안에 datas를 우겨넣을순 없잖아;

datas={}
class ma():
   self.name = datas['이름']
응 동작 안 하겠지.
ㅇㅋ.
..이렇게보니 되면 그게 이상한거같은데요...

하.
global datas
    nostr = backupDatas()
def backupDatas(datas=datas):
안되었다..

집어넣어야만되는듯.;
...???
datas가 {}로 잡혔나;

ㅇㅇ함수선언때 애초에 그러니까말야.
...아닌가;

메소드.

fluid.addn(user,name,no)
는 어떨까.괜찮은데..매우우아하고.동의함.오...오...
단일함수가아니라 메소드자체에접근하고
변수등은그안에저장된다.
신개념이다.매우우아함.
!
그래,애초에 raw하게 플라스크에서 이걸 끌어쓰는게 이상했던거야!

하긴,db를 안거치고서 애초에 접촉할 일이 없던거야!!

valueText = datas[no][key]
지금은 이걸 막 끌고오는데
valueText = minidb.datas[no][key]
이렇게만되면됨.직접접속할거면.
fluiddb.fluid[no][key]
ㅇㅇ동일하다.
하..진짜멋있군.


아 녹화할걸. 어제 12시부터 8시간,오늘 3시간이 어마어마했다정말.

심지어 db를 py로 두고
이전엔 함수실행목록이었던게, 지금은 그냥 변수까지 넣어버려서 처리할수있게됨.
별거아닌데 충격적인 개념의 확장이다.

마치 클래스 fluiddb 를 둔 마냥 ,내부 메소드,변수를 이용하게되었다.ㅇㅋ.

오후 5:36 2020-10-29
크롤링했고,밥먹었고. 2018년6월까지했으며 오류 2개나왔다.

오후 5:52 2020-10-29
실패뜨면, 이전의 fluid를 교체하는건..하지말고;
실패는 깔끔하게 반환하는걸로하고
근데 그건할만하네 ㄹㅇ;인데 매번 fluid를 백업하는게 심히 빡칠거같은데요..
len(fluid)이랑은 노상관이고.ㅇㅋ.그럼냅두지뭐 ..가아니고
len(fluid[no])도 동일함.ㅇㅋ.냅두자;

oldno = fluid[no]
if oldno != fluid[no]:
 open ( errlog,encodeing)
write
close

는 할 만할듯.동의는함..
인데, 매번 체크구문 써야하는거 정신나갈거야.하지 말자!

아냐,저기에하는거라할만할거야.?
근데 except...여도 ㅇㅇ그러네 , fluiddb측에서 에러남기면되니.ㄱㄱ.

o==fluid['33']
말도안되는일인데, o가 복사가 아니라 참조로들어간듯함.세상에나..!

n=0
a= n
n+=1
a
이건괜찮은데말야.

a= dict( fluid['33'] )
심지어 이것도..
아하.형변환해서하지.ㅇㅋ.

oldno = str( fluid['33'] )
ㅎㅎ잘됨.ㅇㅋ.

중복태그가허용된다. 카운트도올라갔고. 리스트는중복못거르니.ㅇㅋ.
'밥줘' in fluid['33']['유저태그']
로 ㄱㄱ.ㅇㅋ.

if no in fluid.keys():
            1+'1'
이따위 판별문괜찮겠지? raiseerr를 한것.
no가, 플루이드키에 없어야만해.
있으면 오류나게해야하는데..
오후 7:27 2020-10-29
작업재개.

logue를 두개 운용해야겠다가 된다.

datas엔,그러나,딱히..
아 ㅋㅋㅋ 애초애ㅔ fluid니까 로그가 있는거군.ㅇㅋ.
datas는 별개로운용되고.ㅇㅋ.

플루이드에이미있는경우, set을못하게해야겠지?
응.지우고 초기화 하세요.
del fluid['33']
ㅇㅋ.

플루이드보고 백업하라해야해.ㅇㅋ..
