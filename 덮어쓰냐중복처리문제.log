
덮어쓰기가좋긴한게, 그냥만들면되잖아.
근데 만든다 라는것에서 또 문제생기고..어휴ㅣ;;;

애초에 그냥 이미 dict에 있으면 안 넣게 해야지;
근데 dict에 없는데 저기가니 파일이 있다 이따위면 어휴'
1카피트리로 오리진은 무조건 가고.ㅇㅋ.
2.오리진에서,파일을 pil써서 옮기는것이다.
2.이떄 dict에 이미있는경우 추가되면 진짜빡칠듯.
newDatas[no][resizedKey] = resizedList
datas = appendDict(datas , newDatas)
로 흘러간다..더는몰겠고..
1차원적 키를 추가하는걸거야.ㅇㅋ..
는내가만든함수였다. 멋지네. 키가 없으면,그대로배정함.ㅇㅋ.
있으면 근데 안 넣는다. 없을때가 보증되어야 함.
..마땅히그렇지!!
이게 이런 제약이 너무 많아져버렸어.
대체 왜 이미 있는걸 넣을 생각을 하는거냐고!!

이미있으면 지우고치워야해..어휴..
근데 크롤러에서 ㄹㅇ 무작위하게 긁은뒤에 던져버리니까 필요하지싶어.
구간 정확히 맞추기 힘들고.

1.자리스트에, 넘버가 datas에 있으면 옮기기.ㅇㅋ.

os.rename('n.txt','./d/ej.txt')
도 이미있으므로발생.
remove로 지워버리자..
이미있으면지우자.ㅇㅋ.
트라이로.ㅇㅋ.
아냐..내가바보였어 txt를 왜 검출하냐고.. listdir에서 dir만가져와야지..


.......오후 8:29 2020-10-28
이거,, 이미 있는경우, 새걸로 교체한다..
인데 static이니 상관없지뭐! 하 하!
원래목적이충실히됨.
아냐..없으면 오버라이트고,있으면 안건드려요..어후..

자스캔.파일버리거나옮기고. 트래시빈은 양심적으로 비워주셈.. 명령어넣을까싶다.

자리스트가 0이 아닌경우. dir가 있다.
dir이 있으면, 심지어 dict에 없었더라도, 그냥 파기함이 옳다. strict 정책을 취하자.
일단 없으면 다 버려버리기로..
있는거 다 지우고할래? 차라리이게낫지.

새로운녀석을 환영하는정책이었는데, 최대한 막는정책으로가자. 그래야 편하게 넣으니.
변경은 이렇게 애초에 하지 않느것으로. 전엔 아마 getjar로 업데이트도 수행하려는게 목적이었을거야.

근데그럼 모바일도아니고, 차라리이게백번낫지않나..???
오프라인상태에서 조용히 수정을 완벽히 할 수 있어.어어???그러네??
수정모드 를 따로 두자.getjar는 새거만 받아들이게. ..??
ㅇㅇ 애초에 크롤링결과포맷을 가시성고려해서만들었으니말야.ㅇㅇ매우동의함.
근데 혼재를막기위해 반드시필요함.
업뎃이랑 getjar랑 구분한다!

1.겟자. 우르르넣어도 dict에있으면거르기 - 오리폴더이미있으면 거르기. 이거면충분하고,아예접근막자.

2.수정자. 여기꺼는,포맷맞춰올리면, 심지어 이미 있어도..가아니고 다 지워버리고 새로 얻자.
관리자페이지에서 origins폴더껄 가져오게하자. 크롤링하던가. 
dict는 삭제이력으로 기록해두고, 폴더는 쓰레기통2에 버리던가하지뭐.

둘 다 어떤경우에도,이미있는 img를 깨부수고 집어넣지 않도록.
ㅇㅋ매우훌륭.
핀셋수정을 그럼 안 하게되었다.매우현명한듯..

모바일에서 수정이 불가능하다는 치명적 문제가 있는데요..
보다가 엇!하고 수정이 불가능함.
아근데 누가모바일수정하냐고;;;
글고 모바일수정되면, txt긴한데,, 인젝션은안되겠지뭐..ㅇㅇ.

하..
삭제
라는걸 하게 냅두면 안되나싶기도 함..
정신나간거같아..
무조건덮어쓰기정책이 낫긴 하다.ㅇㅇ.
그럼 영영 삭제는 없는거야??
응..그런것이다...

아니 삭제나 덮어쓰기나!
아!!!

대충하자.머리를놓고.

ㅇㅇ 지금도, 보면, 겟자하는데 이미 검증완료였을 datas에 키가 또 있냐를 묻잖아.이러면별로야!

이게,함수덩치가 이상하게커져.
예외가발생하는 그시점에추가하니 이상해지고
구조저적으로 ㅈ작은게동작되게하고
그게아닌가를 사전에검증하게해야지...좋겠다.
내부에 자꾸 2중3중검출을하게하니 너무저질스러워짐.그게실패하면또어쩌려고??
애초에 맞을거란가정을하고하기보단
맞다는확신을 미리 검사하고가자.

지금은 getjar할때, dict의 덮어쓰기가 가능해보여.
datas는 완벽히 독립시키자. 그러면 키 덮어쓰기도 괜찮음.ㅇㅇ.

근데그래도 있으면덮어쓰기가아니고,,,막검사하지말고

일단 dict를 그냥 제거해버린뒤에 하던가해야지원;

심각한문제가, datas랑 json이 다르게동작하겠다.
서버측에 불러오는걸로 지금 입력해버리니까 곤란함.

datas[no]
랑

fluids[no]
를 구분하지뭐.

이러면결국 거대유일json이 아닌
마구분할된녀석이 이렇게 탄생해버리는군...후..


1.자스캔.기존딕트없음,오리진,썸넬,리사이즈 폴더가 없으면
알아서잘처리해서넣는다.
오직새것만 받아들이기위해. dict에 바로추가까지함.ㅇㅋ.

2.중복자스캔은 딕트없음에서 걸러진다.

2.수정자스캔.. ..
아오죽겠다.
함정에 빠진걸까?

플루이드는 근데 ㅇatas에 안 두는게좋지..?



오후 9:36 2020-10-28
매우간결히되었다.역시간결한게좋지.
1.getjar는, dict에 있으면 버리고, 없으면 한다. paste에 옮기고,이미있으면삭제.
2.crystaljar는, dict에 없으면수행 안 한다. dict에 있으면, datas와 dir들을 모두 옮기고, getjar마냥수행한다.
3.삭제는, 삭제시, datas지우고, fluids도 지우고, 폴더도지운다.

예외는없다.

핀셋수정기능을 제거한다. 새로추가할거면하고,수정할거면 원본받아서수정해서넣어라.
원본내보내기는,origins를 그대로 압축해서 깔끔히 수행됨.

오후 9:40 2020-10-28
정리완료.휴.

이전엔,
dict점검,갯수다르면,그러고도 또 폴더없으면, 그러고도 또 이미존재하는폴더면, 그런데 jpg가이미있으면..
식이었다.어휴;

오후 9:42 2020-10-28
dumpjar\\.gitattributes'
는뭐냐..하..
지우는명령은 조심히행하고, A외의전부는..식을 지양하자..

False 89
False 89 - 복사본
False 89.txt
하...isdir안먹힘.
datas len:  2
True 89
True 89 - 
 os.path.isdir( os.path.join(jar,i) ) ,i)
응 내가 바보라서 그래..
오후 10:11 2020-10-28

txtFile = os.path.join( jar,noFolder,noFolder+'.txt')
'dumpjar\\89 - 복사본\\89 - 복사본.txt'
를 찾는다. 대체.. 이건 독립적이어야하지않을까..?
그리고,폴더-txt는 일치하는게좋겠어.
근데 무수한 이상한 예외들이 ..은 애초에 다르게놓고
jar에는 투고식이지만, 애초에 신뢰불가한입력은 안 받는게 좋겠지.. ...?
그러니까, 이걸 애초에 저기입구에서 걸러야지 여기까지와서 이러고있으면 안 된다고!!!

tmpKey = parsedDict[idKey] 
정작 datas랑 비교하는건 이렇게 역으로 얻네..흠..

jarscan은 무조건 list를반환하고..
어휴; 여기선 애초에 0이아니면 바로 getjar를지르고보는구만;

서버는 돌아가야하니,
오류가 어쨌든 생기면, 내가예상한상황이아니면, 버려버린다 를 수행하는게어때.
겟 자 게선 가능할듯.좀뒤에보자..
오후 10:24 2020-10-28
어휴
오후 11:17 2020-10-28
어휴
os.rename('89','./ha/89')
이게되네 폴더전체이동도됨.
shtuil move는 오류발생.이미있으면.이건 최종네임을 지정가능하니굿.

pastebin을, getjar 수행전에 비우자. 동의함.
?
오후 11:59 2020-10-28
잘하고있는듯함.
continue 써서 for문 빠르게 없애고
반영을 가능한 우아하게하려함.

1.parse시도. txt네임이 일치안하면, getjar에 방치해서, 수동처리하게해준..다..? 어휴;
인터페이스라고보면 서버측에 직접 손을 안 대는게 목적이잖아요. ..매우동감함.
그럼 수없이쌓이는 로그파일은??? ..겟자할때만 들어가니 많이없을듯.; 해봐야 1메가씩 100개도안되겠고.

강력정책취할까 싶어.
txt파일규격맞고 img파일들 왕창 있으면 다 들어가게해주되
폴더명은 무관하면 어떨까..
ㅇㅇ 번역만화폴더에서, 규격에맞는 txt파일만있음되지.그게 더 보기편하겠어.
폴더명이 id니까 진짜 보기 별로야!!혁명을진행한다.
noFolderpath = os.path.join( jar,noFolder )
어쩌냐..
그리고 id는 숫자여야한다 하는 규칙을 잡자.
type(int('32323')) 로 base10일때만검사함.굿.

에러가발생하면모두납치해서, jar에서 없이하고,
jar에 막 이상한 소형파일이생길수도있는데 그것만은 이해하자 ㅇㅋ;
1.지운다 ..영영소멸..
2.pastebin에넣는다.. 다음주기시소멸. ㅇㅋ이거로.

만화제목명폴더 =>id하고 그림파일들.. 이건승인하게하자.그럼매우흐뭇할듯.동의함.
id만큼은 번호여야 해..ㅇㅋ.
id가 번호에 이미 있으면 오류가 나는데,,그럼 다른아이디를 쓰라고 어케눈치채지???
지금구조에선 폴더없애고, 쓰레기통에 보내는걸로 처리되고 있어.
흠..

겟자돌리면 어떻게든 newdatas가 나오는게 지금이고..

뭔가논리가이상한데..

1.자에넣는다.
2겟자를수행한다
3겟자에서, 조건에맞으면, newdatas를만든다.
4.조건에안맞으면,, 쓰레기통에넘기고 다음!한다.

이건다른인터페이스로 가야하나?

파일:에 압축파일을 넣는다 치자.ㅇㅇ이게유일한방법이자,투고 라고 불리는 행위이다.
1.압축파일전송받으면, 내부엔 규격에맞는txt가있음.
2.압축풀고 ,말하자면 겟자를 수행함. newdict를 얻음.
newdict가 비었으면,오류가났단소리므로, 오류!다시해오세요!를 한다. 근데원인은모름...
이건 조금만 수정하면되겠다. 겟자말고 다른 겟자를쓸까싶다.
newdatas하고, 에러로그를,리턴하게하자.()로묶고.ㅇㅋ..인데 썩 기분나쁘지..?
근데 지금내서버에서도 해야하니 ㄱㄱ.ㅇㅋ.

originPath = os.path.join( origins , noFolder )
이게 다 이따위이다. 이것들 전부 id로 바꿔야겠지???ㅇㅇ.그래야안겹침.ㅇㅋ.
핵시믄, 그거다,,noflder는 처음 iter맨줄에서쓰고더안쓰임.개꿀.

newdict t는 datas에추가되고..이상. 지우려면 매우깔끔히삭제가능.ㅇㅋ.
와.이구조면 나도 그냥 올리기 되겠다.개꿀ㅋㅋㅋㅋ

어딘가에서 *.*으로 불러오던기억이 나...그걸로불러와서..처리하게할까..
설정파일은 파일이름을 규정지을까?? 그럼 id충돌문제발생..흠..
설정.txt
가 수없이많아지니말야. 크롤러에선 용납할수없어요!인데,
솔직히괜찮지싶어.ㅇㅇㅇㅇㅇㅇ.
ㅇㅋ.가자.
x.txt면 일단 그걸 로드하고보는것이다..?
1.id.txt
2.'설정.txt'
이거만 받게하자싶은데..그럼 조건에도괜찮고..
아냐그건미친소리고

유일하게문제되는건 설정이없거나_오류로처리됨
기타다른txt가있거나 인데, 그경우엔, 설정.txt를부르도록하지.이상.
1.txt가한개거나 2.설정.txt가 있게 하자.ㅇㅋ ...설정.txt.txt도 받을까;

